{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { unpackString, unpack } from './parsers/binary';\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\n\nexport class RIFFFile {\n  constructor() {\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\n    this.container = '';\n    /**\r\n     * @type {number}\r\n     */\n\n    this.chunkSize = 0;\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\n\n    this.format = '';\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\n\n    this.signature = null;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.head = 0;\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n\n    this.uInt32 = {\n      bits: 32,\n      be: false\n    };\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\n\n    this.supported_containers = ['RIFF', 'RIFX'];\n  }\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\n\n\n  setSignature(buffer) {\n    this.head = 0;\n    this.container = this.readString(buffer, 4);\n\n    if (this.supported_containers.indexOf(this.container) === -1) {\n      throw Error('Not a supported format.');\n    }\n\n    this.uInt32.be = this.container === 'RIFX';\n    this.chunkSize = this.readUInt32(buffer);\n    this.format = this.readString(buffer, 4); // The RIFF file signature\n\n    this.signature = {\n      chunkId: this.container,\n      chunkSize: this.chunkSize,\n      format: this.format,\n      subChunks: this.getSubChunksIndex_(buffer)\n    };\n  }\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\n\n\n  findChunk(chunkId) {\n    let multiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /** @type {!Array<Object>} */\n    let chunks = this.signature.subChunks;\n    /** @type {!Array<Object>} */\n\n    let chunk = [];\n\n    for (let i = 0; i < chunks.length; i++) {\n      if (chunks[i].chunkId == chunkId) {\n        if (multiple) {\n          chunk.push(chunks[i]);\n        } else {\n          return chunks[i];\n        }\n      }\n    }\n\n    if (chunkId == 'LIST') {\n      return chunk.length ? chunk : null;\n    }\n\n    return null;\n  }\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\n\n\n  readString(bytes, maxSize) {\n    /** @type {string} */\n    let str = '';\n    str = unpackString(bytes, this.head, this.head + maxSize);\n    this.head += maxSize;\n    return str;\n  }\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\n\n\n  readUInt32(bytes) {\n    /** @type {number} */\n    let value = unpack(bytes, this.uInt32, this.head);\n    this.head += 4;\n    return value;\n  }\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\n\n\n  getSubChunksIndex_(buffer) {\n    /** @type {!Array<!Object>} */\n    let chunks = [];\n    /** @type {number} */\n\n    let i = this.head;\n\n    while (i <= buffer.length - 8) {\n      chunks.push(this.getSubChunkIndex_(buffer, i));\n      i += 8 + chunks[chunks.length - 1].chunkSize;\n      i = i % 2 ? i + 1 : i;\n    }\n\n    return chunks;\n  }\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\n\n\n  getSubChunkIndex_(buffer, index) {\n    /** @type {!Object} */\n    let chunk = {\n      chunkId: this.getChunkId_(buffer, index),\n      chunkSize: this.getChunkSize_(buffer, index)\n    };\n\n    if (chunk.chunkId == 'LIST') {\n      chunk.format = unpackString(buffer, index + 8, index + 12);\n      this.head += 4;\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\n    } else {\n      /** @type {number} */\n      let realChunkSize = chunk.chunkSize % 2 ? chunk.chunkSize + 1 : chunk.chunkSize;\n      this.head = index + 8 + realChunkSize;\n      chunk.chunkData = {\n        start: index + 8,\n        end: this.head\n      };\n    }\n\n    return chunk;\n  }\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\n\n\n  getChunkId_(buffer, index) {\n    this.head += 4;\n    return unpackString(buffer, index, index + 4);\n  }\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\n\n\n  getChunkSize_(buffer, index) {\n    this.head += 4;\n    return unpack(buffer, this.uInt32, index + 4);\n  }\n\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/riff-file.js"],"names":["unpackString","unpack","RIFFFile","constructor","container","chunkSize","format","signature","head","uInt32","bits","be","supported_containers","setSignature","buffer","readString","indexOf","Error","readUInt32","chunkId","subChunks","getSubChunksIndex_","findChunk","multiple","chunks","chunk","i","length","push","bytes","maxSize","str","value","getSubChunkIndex_","index","getChunkId_","getChunkSize_","realChunkSize","chunkData","start","end"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\r\nexport class RIFFFile {\r\n\r\n  constructor() {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\r\n    this.signature = null;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.head = 0;\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt32 = {bits: 32, be: false};\r\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\r\n    this.supported_containers = ['RIFF', 'RIFX'];\r\n  }\r\n\r\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\r\n  setSignature(buffer) {\r\n    this.head = 0;\r\n    this.container = this.readString(buffer, 4);\r\n    if (this.supported_containers.indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.uInt32.be = this.container === 'RIFX';\r\n    this.chunkSize = this.readUInt32(buffer);\r\n    this.format = this.readString(buffer, 4);\r\n    // The RIFF file signature\r\n    this.signature = {\r\n      chunkId: this.container,\r\n      chunkSize: this.chunkSize,\r\n      format: this.format,\r\n      subChunks: this.getSubChunksIndex_(buffer)\r\n    };\r\n  }\r\n\r\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\r\n  findChunk(chunkId, multiple=false) {\r\n    /** @type {!Array<Object>} */\r\n    let chunks = this.signature.subChunks;\r\n    /** @type {!Array<Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i].chunkId == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\r\n  readString(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    str = unpackString(bytes, this.head, this.head + maxSize);\r\n    this.head += maxSize;\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\r\n  readUInt32(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt32, this.head);\r\n    this.head += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunksIndex_(buffer) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunks = [];\r\n    /** @type {number} */\r\n    let i = this.head;\r\n    while(i <= buffer.length - 8) {\r\n      chunks.push(this.getSubChunkIndex_(buffer, i));\r\n      i += 8 + chunks[chunks.length - 1].chunkSize;\r\n      i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n  }\r\n\r\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunkIndex_(buffer, index) {\r\n    /** @type {!Object} */\r\n    let chunk = {\r\n      chunkId: this.getChunkId_(buffer, index),\r\n      chunkSize: this.getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk.chunkId == 'LIST') {\r\n      chunk.format = unpackString(buffer, index + 8, index + 12);\r\n      this.head += 4;\r\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\r\n    } else {\r\n      /** @type {number} */\r\n      let realChunkSize = chunk.chunkSize % 2 ?\r\n        chunk.chunkSize + 1 : chunk.chunkSize;\r\n      this.head = index + 8 + realChunkSize;\r\n      chunk.chunkData = {\r\n        start: index + 8,\r\n        end: this.head\r\n      };\r\n    }\r\n    return chunk;\r\n  }\r\n\r\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\r\n  getChunkId_(buffer, index) {\r\n    this.head += 4;\r\n    return unpackString(buffer, index, index + 4);\r\n  }\r\n\r\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\r\n  getChunkSize_(buffer, index) {\r\n    this.head += 4;\r\n    return unpack(buffer, this.uInt32, index + 4);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}