{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\n\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\nexport class IntParser {\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\n  constructor(bits) {\n    let signed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\n    this.bits = bits;\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\n\n    this.offset = Math.ceil(bits / 8);\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.max = Math.pow(2, bits) - 1;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.min = 0;\n    /**\r\n     * @type {Function}\r\n     */\n\n    this.unpack = this.unpack_;\n\n    if (signed) {\n      this.max = Math.pow(2, bits) / 2 - 1;\n      this.min = -this.max - 1;\n      this.unpack = this.unpackSigned_;\n    }\n  }\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\n\n\n  pack(buffer, num) {\n    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    num = this.clamp_(Math.round(num));\n\n    for (let i = 0, len = this.offset; i < len; i++) {\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\n      index++;\n    }\n\n    return index;\n  }\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  unpack_(buffer) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    /** @type {number} */\n    let num = 0;\n\n    for (let x = 0; x < this.offset; x++) {\n      num += buffer[index + x] * Math.pow(256, x);\n    }\n\n    return num;\n  }\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  unpackSigned_(buffer) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return this.sign_(this.unpack_(buffer, index));\n  }\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\n\n\n  clamp_(num) {\n    if (num > this.max) {\n      return this.max;\n    } else if (num < this.min) {\n      return this.min;\n    }\n\n    return num;\n  }\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  sign_(num) {\n    if (num > this.max) {\n      num -= this.max * 2 + 2;\n    }\n\n    return num;\n  }\n\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/parsers/binary/lib/int-parser.js"],"names":["IntParser","constructor","bits","signed","offset","Math","ceil","max","pow","min","unpack","unpack_","unpackSigned_","pack","buffer","num","index","clamp_","round","i","len","floor","x","sign_"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\r\nexport class IntParser {\r\n  \r\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\r\n  constructor(bits, signed=false) {\r\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil(bits / 8);\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.max = Math.pow(2, bits) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.min = 0;\r\n    /**\r\n     * @type {Function}\r\n     */\r\n    this.unpack = this.unpack_;\r\n    if (signed) {\r\n      this.max = Math.pow(2, bits) / 2 - 1;\r\n      this.min = -this.max - 1;\r\n      this.unpack = this.unpackSigned_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  pack(buffer, num, index=0) {\r\n    num = this.clamp_(Math.round(num));\r\n    for (let i = 0, len = this.offset; i < len; i++) {\r\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\r\n      index++;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpack_(buffer, index=0) {\r\n    /** @type {number} */\r\n    let num = 0;\r\n    for(let x = 0; x < this.offset; x++) {\r\n      num += buffer[index + x] * Math.pow(256, x);\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpackSigned_(buffer, index=0) {\r\n    return this.sign_(this.unpack_(buffer, index));\r\n  }\r\n\r\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  clamp_(num) {\r\n    if (num > this.max) {\r\n      return this.max;\r\n    } else if (num < this.min) {\r\n      return this.min;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}