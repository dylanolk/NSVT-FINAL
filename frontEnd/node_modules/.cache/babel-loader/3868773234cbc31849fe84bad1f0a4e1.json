{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\n\nexport class WaveFileCueEditor extends WaveFileTagEditor {\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\n  listCuePoints() {\n    /** @type {!Array<!Object>} */\n    let points = this.getCuePoints_();\n\n    for (let i = 0, len = points.length; i < len; i++) {\n      // Add attrs that should exist in the object\n      points[i].position = points[i].dwSampleOffset / this.fmt.sampleRate * 1000; // If it is a region, calc the end\n      // position in milliseconds\n\n      if (points[i].dwSampleLength) {\n        points[i].end = points[i].dwSampleLength / this.fmt.sampleRate * 1000;\n        points[i].end += points[i].position; // If its not a region, end should be null\n      } else {\n        points[i].end = null;\n      } // Remove attrs that should not go in the results\n\n\n      delete points[i].value;\n    }\n\n    return points;\n  }\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\n\n\n  setCuePoint(pointData) {\n    this.cue.chunkId = 'cue '; // label attr should always exist\n\n    if (!pointData.label) {\n      pointData.label = '';\n    }\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\n\n\n    let existingPoints = this.getCuePoints_(); // Clear any LIST labeled 'adtl'\n    // The LIST chunk should be re-written\n    // after the new cue point is created\n\n    this.clearLISTadtl_(); // Erase this.cue so it can be re-written\n    // after the point is added\n\n    this.cue.points = [];\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\n\n    pointData.dwSampleOffset = pointData.position * this.fmt.sampleRate / 1000;\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\n\n    pointData.dwSampleLength = 0;\n\n    if (pointData.end) {\n      pointData.dwSampleLength = pointData.end * this.fmt.sampleRate / 1000 - pointData.dwSampleOffset;\n    } // If there were no cue points in the file,\n    // insert the new cue point as the first\n\n\n    if (existingPoints.length === 0) {\n      this.setCuePoint_(pointData, 1); // If the file already had cue points, This new one\n      // must be added in the list according to its position.\n    } else {\n      this.setCuePointInOrder_(existingPoints, pointData);\n    }\n\n    this.cue.dwCuePoints = this.cue.points.length;\n  }\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\n\n\n  deleteCuePoint(index) {\n    this.cue.chunkId = 'cue ';\n    /** @type {!Array<!Object>} */\n\n    let existingPoints = this.getCuePoints_();\n    this.clearLISTadtl_();\n    /** @type {number} */\n\n    let len = this.cue.points.length;\n    this.cue.points = [];\n\n    for (let i = 0; i < len; i++) {\n      if (i + 1 !== index) {\n        this.setCuePoint_(existingPoints[i], i + 1);\n      }\n    }\n\n    this.cue.dwCuePoints = this.cue.points.length;\n\n    if (this.cue.dwCuePoints) {\n      this.cue.chunkId = 'cue ';\n    } else {\n      this.cue.chunkId = '';\n      this.clearLISTadtl_();\n    }\n  }\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\n\n\n  updateLabel(pointIndex, label) {\n    /** @type {?number} */\n    let cIndex = this.getLISTIndex('adtl');\n\n    if (cIndex !== null) {\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\n        if (this.LIST[cIndex].subChunks[i].dwName == pointIndex) {\n          this.LIST[cIndex].subChunks[i].value = label;\n        }\n      }\n    }\n  }\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\n\n\n  getCuePoints_() {\n    /** @type {!Array<!Object>} */\n    let points = [];\n\n    for (let i = 0; i < this.cue.points.length; i++) {\n      /** @type {!Object} */\n      let chunk = this.cue.points[i];\n      /** @type {!Object} */\n\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\n      pointData.label = pointData.value ? pointData.value : '';\n      pointData.dwPosition = chunk.dwPosition;\n      pointData.fccChunk = chunk.fccChunk;\n      pointData.dwChunkStart = chunk.dwChunkStart;\n      pointData.dwBlockStart = chunk.dwBlockStart;\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\n      points.push(pointData);\n    }\n\n    return points;\n  }\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\n\n\n  getDataForCuePoint_(pointDwName) {\n    /** @type {?number} */\n    let LISTindex = this.getLISTIndex('adtl');\n    /** @type {!Object} */\n\n    let pointData = {}; // If there is a adtl LIST in the file, look for\n    // LIST subchunks with data referencing this point\n\n    if (LISTindex !== null) {\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\n    }\n\n    return pointData;\n  }\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\n\n\n  getCueDataFromLIST_(pointData, index, pointDwName) {\n    // got through all chunks in the adtl LIST checking\n    // for references to this cue point\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\n        /** @type {!Object} */\n        let chunk = this.LIST[index].subChunks[i]; // Some chunks may reference the point but\n        // have a empty text; this is to ensure that if\n        // one chunk that reference the point has a text,\n        // this value will be kept as the associated data label\n        // for the cue point.\n        // If different values are present, the last value found\n        // will be considered the label for the cue point.\n\n        pointData.value = chunk.value || pointData.value;\n        pointData.dwName = chunk.dwName || 0;\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\n        pointData.dwCountry = chunk.dwCountry || 0;\n        pointData.dwLanguage = chunk.dwLanguage || 0;\n        pointData.dwDialect = chunk.dwDialect || 0;\n        pointData.dwCodePage = chunk.dwCodePage || 0;\n      }\n    }\n  }\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\n\n\n  setCuePoint_(pointData, dwName) {\n    this.cue.points.push({\n      dwName: dwName,\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\n      dwSampleOffset: pointData.dwSampleOffset\n    });\n    this.setLabl_(pointData, dwName);\n  }\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\n\n\n  setCuePointInOrder_(existingPoints, pointData) {\n    /** @type {boolean} */\n    let hasSet = false; // Iterate over the cue points that existed\n    // before this one was added\n\n    for (let i = 0; i < existingPoints.length; i++) {\n      // If the new point is located before this original point\n      // and the new point have not been created, create the\n      // new point and then the original point\n      if (existingPoints[i].dwSampleOffset > pointData.dwSampleOffset && !hasSet) {\n        // create the new point\n        this.setCuePoint_(pointData, i + 1); // create the original point\n\n        this.setCuePoint_(existingPoints[i], i + 2);\n        hasSet = true; // Otherwise, re-create the original point\n      } else {\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\n      }\n    } // If no point was created in the above loop,\n    // create the new point as the last one\n\n\n    if (!hasSet) {\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\n    }\n  }\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\n\n\n  clearLISTadtl_() {\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\n      if (this.LIST[i].format == 'adtl') {\n        this.LIST.splice(i);\n      }\n    }\n  }\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n\n\n  setLabl_(pointData, dwName) {\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\n    let adtlIndex = this.getLISTIndex('adtl'); // If there is no adtl LIST, create one\n\n    if (adtlIndex === null) {\n      // Include a new item LIST chunk\n      this.LIST.push({\n        chunkId: 'LIST',\n        chunkSize: 4,\n        format: 'adtl',\n        subChunks: []\n      }); // Get the index of the new LIST chunk\n\n      adtlIndex = this.LIST.length - 1;\n    }\n\n    this.setLabelText_(adtlIndex, pointData, dwName);\n\n    if (pointData.dwSampleLength) {\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\n    }\n  }\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n\n\n  setLabelText_(adtlIndex, pointData, dwName) {\n    this.LIST[adtlIndex].subChunks.push({\n      chunkId: 'labl',\n      chunkSize: 4,\n      // should be 4 + label length in bytes\n      dwName: dwName,\n      value: pointData.label\n    });\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\n  }\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n\n\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\n    this.LIST[adtlIndex].subChunks.push({\n      chunkId: 'ltxt',\n      chunkSize: 20,\n      // should be 12 + label byte length\n      dwName: dwName,\n      dwSampleLength: pointData.dwSampleLength,\n      dwPurposeID: pointData.dwPurposeID || 0,\n      dwCountry: pointData.dwCountry || 0,\n      dwLanguage: pointData.dwLanguage || 0,\n      dwDialect: pointData.dwDialect || 0,\n      dwCodePage: pointData.dwCodePage || 0,\n      value: pointData.label // kept for compatibility\n\n    });\n    this.LIST[adtlIndex].chunkSize += 28;\n  }\n\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-cue-editor.js"],"names":["WaveFileTagEditor","WaveFileCueEditor","listCuePoints","points","getCuePoints_","i","len","length","position","dwSampleOffset","fmt","sampleRate","dwSampleLength","end","value","setCuePoint","pointData","cue","chunkId","label","existingPoints","clearLISTadtl_","setCuePoint_","setCuePointInOrder_","dwCuePoints","deleteCuePoint","index","updateLabel","pointIndex","cIndex","getLISTIndex","LIST","subChunks","dwName","chunk","getDataForCuePoint_","dwPosition","fccChunk","dwChunkStart","dwBlockStart","push","pointDwName","LISTindex","getCueDataFromLIST_","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","setLabl_","hasSet","format","splice","adtlIndex","chunkSize","setLabelText_","setLtxtChunk_"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\r\nexport class WaveFileCueEditor extends WaveFileTagEditor {\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\r\n  listCuePoints() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = this.getCuePoints_();\r\n    for (let i = 0, len = points.length; i < len; i++) {\r\n\r\n      // Add attrs that should exist in the object\r\n      points[i].position =\r\n        (points[i].dwSampleOffset / this.fmt.sampleRate) * 1000;\r\n\r\n      // If it is a region, calc the end\r\n      // position in milliseconds\r\n      if (points[i].dwSampleLength) {\r\n        points[i].end =\r\n          (points[i].dwSampleLength / this.fmt.sampleRate) * 1000;\r\n        points[i].end += points[i].position;\r\n      // If its not a region, end should be null\r\n      } else {\r\n        points[i].end = null;\r\n      }\r\n\r\n      // Remove attrs that should not go in the results\r\n      delete points[i].value;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\r\n  setCuePoint(pointData) {\r\n    this.cue.chunkId = 'cue ';\r\n\r\n    // label attr should always exist\r\n    if (!pointData.label) {\r\n      pointData.label = '';\r\n    }\r\n\r\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\r\n    let existingPoints = this.getCuePoints_();\r\n\r\n    // Clear any LIST labeled 'adtl'\r\n    // The LIST chunk should be re-written\r\n    // after the new cue point is created\r\n    this.clearLISTadtl_();\r\n\r\n    // Erase this.cue so it can be re-written\r\n    // after the point is added\r\n    this.cue.points = [];\r\n\r\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleOffset =\r\n      (pointData.position * this.fmt.sampleRate) / 1000;\r\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleLength = 0;\r\n    if (pointData.end) {\r\n      pointData.dwSampleLength = \r\n        ((pointData.end * this.fmt.sampleRate) / 1000) -\r\n        pointData.dwSampleOffset;\r\n    }\r\n\r\n    // If there were no cue points in the file,\r\n    // insert the new cue point as the first\r\n    if (existingPoints.length === 0) {\r\n      this.setCuePoint_(pointData, 1);\r\n\r\n    // If the file already had cue points, This new one\r\n    // must be added in the list according to its position.\r\n    } else {\r\n      this.setCuePointInOrder_(existingPoints, pointData);\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (i + 1 !== index) {\r\n        this.setCuePoint_(existingPoints[i], i + 1);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let cIndex = this.getLISTIndex('adtl');\r\n    if (cIndex !== null) {\r\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\r\n        if (this.LIST[cIndex].subChunks[i].dwName ==\r\n            pointIndex) {\r\n          this.LIST[cIndex].subChunks[i].value = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i = 0; i < this.cue.points.length; i++) {\r\n      /** @type {!Object} */\r\n      let chunk = this.cue.points[i];\r\n      /** @type {!Object} */\r\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\r\n      pointData.label = pointData.value ? pointData.value : '';\r\n      pointData.dwPosition = chunk.dwPosition;\r\n      pointData.fccChunk = chunk.fccChunk;\r\n      pointData.dwChunkStart = chunk.dwChunkStart;\r\n      pointData.dwBlockStart = chunk.dwBlockStart;\r\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\r\n      points.push(pointData);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\r\n  getDataForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let LISTindex = this.getLISTIndex('adtl');\r\n    /** @type {!Object} */\r\n    let pointData = {};\r\n    // If there is a adtl LIST in the file, look for\r\n    // LIST subchunks with data referencing this point\r\n    if (LISTindex !== null) {\r\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\r\n    }\r\n    return pointData;\r\n  }\r\n\r\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  getCueDataFromLIST_(pointData, index, pointDwName) {\r\n    // got through all chunks in the adtl LIST checking\r\n    // for references to this cue point\r\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\r\n        /** @type {!Object} */\r\n        let chunk = this.LIST[index].subChunks[i];\r\n        // Some chunks may reference the point but\r\n        // have a empty text; this is to ensure that if\r\n        // one chunk that reference the point has a text,\r\n        // this value will be kept as the associated data label\r\n        // for the cue point.\r\n        // If different values are present, the last value found\r\n        // will be considered the label for the cue point.\r\n        pointData.value = chunk.value || pointData.value;\r\n        pointData.dwName = chunk.dwName || 0;\r\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\r\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\r\n        pointData.dwCountry = chunk.dwCountry || 0;\r\n        pointData.dwLanguage = chunk.dwLanguage || 0;\r\n        pointData.dwDialect = chunk.dwDialect || 0;\r\n        pointData.dwCodePage = chunk.dwCodePage || 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(pointData, dwName) {\r\n    this.cue.points.push({\r\n      dwName: dwName,\r\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\r\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\r\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\r\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\r\n      dwSampleOffset: pointData.dwSampleOffset\r\n    });\r\n    this.setLabl_(pointData, dwName);\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\r\n  setCuePointInOrder_(existingPoints, pointData) {\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n\r\n    // Iterate over the cue points that existed\r\n    // before this one was added\r\n    for (let i = 0; i < existingPoints.length; i++) {\r\n\r\n      // If the new point is located before this original point\r\n      // and the new point have not been created, create the\r\n      // new point and then the original point\r\n      if (existingPoints[i].dwSampleOffset > \r\n        pointData.dwSampleOffset && !hasSet) {\r\n        // create the new point\r\n        this.setCuePoint_(pointData, i + 1);\r\n\r\n        // create the original point\r\n        this.setCuePoint_(existingPoints[i], i + 2);\r\n        hasSet = true;\r\n\r\n      // Otherwise, re-create the original point\r\n      } else {\r\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\r\n      }\r\n    }\r\n    // If no point was created in the above loop,\r\n    // create the new point as the last one\r\n    if (!hasSet) {\r\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(pointData, dwName) {\r\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\r\n    let adtlIndex = this.getLISTIndex('adtl');\r\n    // If there is no adtl LIST, create one\r\n    if (adtlIndex === null) {\r\n      // Include a new item LIST chunk\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 4,\r\n        format: 'adtl',\r\n        subChunks: []});\r\n      // Get the index of the new LIST chunk\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex, pointData, dwName);\r\n    if (pointData.dwSampleLength) {\r\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'labl',\r\n      chunkSize: 4, // should be 4 + label length in bytes\r\n      dwName: dwName,\r\n      value: pointData.label\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\r\n  }\r\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'ltxt',\r\n      chunkSize: 20,  // should be 12 + label byte length\r\n      dwName: dwName,\r\n      dwSampleLength: pointData.dwSampleLength,\r\n      dwPurposeID: pointData.dwPurposeID || 0,\r\n      dwCountry: pointData.dwCountry || 0,\r\n      dwLanguage: pointData.dwLanguage || 0,\r\n      dwDialect: pointData.dwDialect || 0,\r\n      dwCodePage: pointData.dwCodePage || 0,\r\n      value: pointData.label // kept for compatibility\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 28;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}