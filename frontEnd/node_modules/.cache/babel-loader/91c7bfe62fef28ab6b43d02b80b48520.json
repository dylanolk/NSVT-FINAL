{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { changeBitDepth } from './codecs/bitdepth';\nimport * as imaadpcm from './codecs/imaadpcm';\nimport * as alaw from './codecs/alaw';\nimport * as mulaw from './codecs/mulaw';\nimport { unpackArrayTo } from './parsers/binary';\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { resample } from './resampler';\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\n\nexport class WaveFileConverter extends WaveFileCueEditor {\n  /**\r\n   * Force a file as RIFF.\r\n   */\n  toRIFF() {\n    /** @type {!Float64Array} */\n    let output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n      container: 'RIFF'\n    });\n  }\n  /**\r\n   * Force a file as RIFX.\r\n   */\n\n\n  toRIFX() {\n    /** @type {!Float64Array} */\n    let output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n      container: 'RIFX'\n    });\n  }\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\n\n\n  toIMAADPCM() {\n    if (this.fmt.sampleRate !== 8000) {\n      throw new Error('Only 8000 Hz files can be compressed as IMA-ADPCM.');\n    } else if (this.fmt.numChannels !== 1) {\n      throw new Error('Only mono files can be compressed as IMA-ADPCM.');\n    } else {\n      this.assure16Bit_();\n      /** @type {!Int16Array} */\n\n      let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '4', imaadpcm.encode(output), {\n        container: this.correctContainer_()\n      });\n    }\n  }\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n\n\n  fromIMAADPCM() {\n    let bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', imaadpcm.decode(this.data.samples, this.fmt.blockAlign), {\n      container: this.correctContainer_()\n    });\n\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\n\n\n  toALaw() {\n    this.assure16Bit_();\n    /** @type {!Int16Array} */\n\n    let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8a', alaw.encode(output), {\n      container: this.correctContainer_()\n    });\n  }\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n\n\n  fromALaw() {\n    let bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', alaw.decode(this.data.samples), {\n      container: this.correctContainer_()\n    });\n\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\n\n\n  toMuLaw() {\n    this.assure16Bit_();\n    /** @type {!Int16Array} */\n\n    let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8m', mulaw.encode(output), {\n      container: this.correctContainer_()\n    });\n  }\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n\n\n  fromMuLaw() {\n    let bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', mulaw.decode(this.data.samples), {\n      container: this.correctContainer_()\n    });\n\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\n\n\n  toBitDepth(newBitDepth) {\n    let changeResolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    /** @type {string} */\n    let toBitDepth = newBitDepth;\n    /** @type {string} */\n\n    let thisBitDepth = this.bitDepth;\n\n    if (!changeResolution) {\n      if (newBitDepth != '32f') {\n        toBitDepth = this.dataType.bits.toString();\n      }\n\n      thisBitDepth = '' + this.dataType.bits;\n    } // If the file is compressed, make it\n    // PCM before changing the bit depth\n\n\n    this.assureUncompressed_();\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\n\n    let samples = this.getSamples(true);\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\n\n    let newSamples = new Float64Array(samples.length); // Change the bit depth\n\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth); // Re-create the file\n\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, newBitDepth, newSamples, {\n      container: this.correctContainer_()\n    });\n  }\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\n\n\n  toSampleRate(sampleRate, options) {\n    this.validateResample_(sampleRate);\n    /** @type {!(Array|TypedArray)} */\n\n    let samples = this.getSamples();\n    /** @type {!(Array|Float64Array)} */\n\n    let newSamples = []; // Mono files\n\n    if (samples.constructor === Float64Array) {\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options); // Multi-channel files\n    } else {\n      for (let i = 0; i < samples.length; i++) {\n        newSamples.push(resample(samples[i], this.fmt.sampleRate, sampleRate, options));\n      }\n    } // Recreate the file\n\n\n    this.fromExisting_(this.fmt.numChannels, sampleRate, this.bitDepth, newSamples, {\n      'container': this.correctContainer_()\n    });\n  }\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\n\n\n  validateResample_(sampleRate) {\n    if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\n      throw new Error('Invalid sample rate.');\n    } else if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n      throw new Error('wavefile can\\'t change the sample rate of compressed files.');\n    }\n  }\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\n\n\n  assure16Bit_() {\n    this.assureUncompressed_();\n\n    if (this.bitDepth != '16') {\n      this.toBitDepth('16');\n    }\n  }\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\n\n\n  assureUncompressed_() {\n    if (this.bitDepth == '8a') {\n      this.fromALaw();\n    } else if (this.bitDepth == '8m') {\n      this.fromMuLaw();\n    } else if (this.bitDepth == '4') {\n      this.fromIMAADPCM();\n    }\n  }\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\n\n\n  correctContainer_() {\n    return this.container == 'RF64' ? 'RIFF' : this.container;\n  }\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\n\n\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\n    /** @type {!Object} */\n    let tmpWav = new WaveFileCueEditor();\n    Object.assign(this.fmt, tmpWav.fmt);\n    Object.assign(this.fact, tmpWav.fact);\n    Object.assign(this.ds64, tmpWav.ds64);\n    Object.assign(this.data, tmpWav.data);\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n  }\n\n}\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\n\nfunction outputSize_(byteLen, byteOffset) {\n  /** @type {number} */\n  let outputSize = byteLen / byteOffset;\n\n  if (outputSize % 2) {\n    outputSize++;\n  }\n\n  return outputSize;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-converter.js"],"names":["changeBitDepth","imaadpcm","alaw","mulaw","unpackArrayTo","WaveFileCueEditor","validateSampleRate","resample","WaveFileConverter","toRIFF","output","Float64Array","outputSize_","data","samples","length","dataType","bits","fromExisting_","fmt","numChannels","sampleRate","bitDepth","container","toRIFX","toIMAADPCM","Error","assure16Bit_","Int16Array","encode","correctContainer_","fromIMAADPCM","bitDepthCode","decode","blockAlign","toBitDepth","toALaw","fromALaw","toMuLaw","fromMuLaw","newBitDepth","changeResolution","thisBitDepth","toString","assureUncompressed_","getSamples","newSamples","toSampleRate","options","validateResample_","constructor","i","push","bitsPerSample","indexOf","tmpWav","Object","assign","fact","ds64","newWavFile_","byteLen","byteOffset","outputSize"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { changeBitDepth } from './codecs/bitdepth';\r\nimport * as imaadpcm from './codecs/imaadpcm';\r\nimport * as alaw from './codecs/alaw';\r\nimport * as mulaw from './codecs/mulaw';\r\nimport { unpackArrayTo } from './parsers/binary';\r\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { resample } from './resampler';\r\n\r\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\r\nexport class WaveFileConverter extends WaveFileCueEditor {\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   */\r\n  toRIFF() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFF'});\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   */\r\n  toRIFX() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFX'});\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate !== 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if (this.fmt.numChannels !== 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      /** @type {!Int16Array} */\r\n      let output = new Int16Array(\r\n        outputSize_(this.data.samples.length, 2));\r\n      unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n      this.fromExisting_(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        imaadpcm.encode(output),\r\n        {container: this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromIMAADPCM(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      imaadpcm.decode(this.data.samples, this.fmt.blockAlign),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromALaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      mulaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromMuLaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      mulaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\r\n  toBitDepth(newBitDepth, changeResolution=true) {\r\n    /** @type {string} */\r\n    let toBitDepth = newBitDepth;\r\n    /** @type {string} */\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      if (newBitDepth != '32f') {\r\n        toBitDepth = this.dataType.bits.toString();\r\n      }\r\n      thisBitDepth = '' + this.dataType.bits;\r\n    }\r\n    // If the file is compressed, make it\r\n    // PCM before changing the bit depth\r\n    this.assureUncompressed_();\r\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = this.getSamples(true);\r\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\r\n    let newSamples = new Float64Array(samples.length);\r\n    // Change the bit depth\r\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth);\r\n    // Re-create the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      newBitDepth,\r\n      newSamples,\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\r\n  toSampleRate(sampleRate, options) {\r\n    this.validateResample_(sampleRate);\r\n    /** @type {!(Array|TypedArray)} */\r\n    let samples = this.getSamples();\r\n    /** @type {!(Array|Float64Array)} */\r\n    let newSamples = [];\r\n    // Mono files\r\n    if (samples.constructor === Float64Array) {\r\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options);\r\n    // Multi-channel files\r\n    } else {\r\n      for (let i = 0; i < samples.length; i++) {\r\n        newSamples.push(resample(\r\n          samples[i], this.fmt.sampleRate, sampleRate, options));\r\n      }\r\n    }\r\n    // Recreate the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels, sampleRate, this.bitDepth, newSamples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\r\n  validateResample_(sampleRate) {\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    } else if (['4','8a','8m'].indexOf(this.bitDepth) > -1) {\r\n      throw new Error(\r\n        'wavefile can\\'t change the sample rate of compressed files.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if (this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileCueEditor();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction outputSize_(byteLen, byteOffset) {\r\n  /** @type {number} */\r\n  let outputSize = byteLen / byteOffset;\r\n  if (outputSize % 2) {\r\n    outputSize++;\r\n  }\r\n  return outputSize;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}