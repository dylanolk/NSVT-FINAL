{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview binary parser.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { endianness } from './lib/endianness';\nimport { pack as packUTF8, unpack as unpackUTF8 } from './lib/utf8-parser';\nimport { IntParser } from './lib/int-parser';\nimport { FloatParser } from './lib/float-parser';\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\n\nexport function unpackString(buffer) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buffer.length;\n  return unpackUTF8(buffer, index, end);\n}\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\n\nexport function packString(str) {\n  /** @type {!Array<number>} */\n  let buffer = [];\n  packUTF8(str, buffer);\n  return buffer;\n}\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\n\nexport function packStringTo(str, buffer) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return packUTF8(str, buffer, index);\n} // Numbers\n\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\n\nexport function packArrayTo(values, theType, buffer) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  theType = theType || {};\n  /** @type {!Object} */\n\n  let packer = getParser_(theType.bits, theType.fp, theType.signed);\n  /** @type {number} */\n\n  let offset = Math.ceil(theType.bits / 8);\n  /** @type {number} */\n\n  let i = 0;\n  /** @type {number} */\n\n  let start = index;\n\n  for (let valuesLen = values.length; i < valuesLen; i++) {\n    index = packer.pack(buffer, values[i], index);\n  }\n\n  if (theType.be) {\n    endianness(buffer, offset, start, index);\n  }\n\n  return index;\n}\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @throws {Error} If the type definition is not valid.\r\n */\n\nexport function unpackArrayTo(buffer, theType, output) {\n  let start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : buffer.length;\n  theType = theType || {};\n  /** @type {!Object} */\n\n  let parser = getParser_(theType.bits, theType.fp, theType.signed); // getUnpackLen_ will adjust the end index according to the size\n  // of the input buffer and the byte offset or throw a error on bad\n  // end index if safe=true\n\n  end = getUnpackLen_(buffer, start, end, parser.offset);\n\n  if (theType.be) {\n    /** @type {!(Uint8Array|Array<number>)} */\n    let readBuffer = copyBuffer_(buffer);\n\n    if (theType.be) {\n      endianness(readBuffer, parser.offset, start, end);\n    }\n\n    unpack_(readBuffer, output, start, end, parser);\n  } else {\n    unpack_(buffer, output, start, end, parser);\n  }\n}\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\n\nexport function packTo(value, theType, buffer) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return packArrayTo([value], theType, buffer, index);\n}\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n */\n\nexport function pack(value, theType) {\n  /** @type {!Array<number>} */\n  let output = [];\n  packTo(value, theType, output, 0);\n  return output;\n}\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid.\r\n */\n\nexport function unpack(buffer, theType) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let output = [];\n  unpackArrayTo(buffer, theType, output, index, index + Math.ceil(theType.bits / 8));\n  return output[0];\n}\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {!Object} parser The parser.\r\n * @private\r\n */\n\nfunction unpack_(buffer, output, start, end, parser) {\n  /** @type {number} */\n  let offset = parser.offset;\n\n  for (let index = 0, j = start; j < end; j += offset, index++) {\n    output[index] = parser.unpack(buffer, j);\n  }\n}\n/**\r\n * Copy a byte buffer as a Array or Uint8Array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @return {!(Uint8Array|Array<number>)}\r\n * @private\r\n */\n\n\nfunction copyBuffer_(buffer) {\n  return new Uint8Array(buffer);\n}\n/**\r\n * Adjust the end index according to the input buffer length and the\r\n * type offset.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @private\r\n */\n\n\nfunction getUnpackLen_(buffer, start, end, offset) {\n  /** @type {number} */\n  let extra = (end - start) % offset;\n  return end - extra;\n}\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\n\n\nfunction getParser_(bits, fp, signed) {\n  if (fp && bits == 32) {\n    return new FloatParser(8, 23);\n  } else if (fp && bits == 64) {\n    return new FloatParser(11, 52);\n  }\n\n  return new IntParser(bits, signed);\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/parsers/binary/index.js"],"names":["endianness","pack","packUTF8","unpack","unpackUTF8","IntParser","FloatParser","unpackString","buffer","index","end","length","packString","str","packStringTo","packArrayTo","values","theType","packer","getParser_","bits","fp","signed","offset","Math","ceil","i","start","valuesLen","be","unpackArrayTo","output","parser","getUnpackLen_","readBuffer","copyBuffer_","unpack_","packTo","value","j","Uint8Array","extra"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview binary parser.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { endianness } from './lib/endianness';\r\nimport { pack as packUTF8, unpack as unpackUTF8 } from './lib/utf8-parser';\r\nimport { IntParser } from './lib/int-parser';\r\nimport { FloatParser } from './lib/float-parser';\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\r\nexport function unpackString(buffer, index=0, end=buffer.length) {\r\n  return unpackUTF8(buffer, index, end);\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\r\nexport function packString(str) {\r\n  /** @type {!Array<number>} */\r\n  let buffer = [];\r\n  packUTF8(str, buffer);\r\n  return buffer;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function packStringTo(str, buffer, index=0) {\r\n  return packUTF8(str, buffer, index);\r\n}\r\n\r\n// Numbers\r\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packArrayTo(values, theType, buffer, index=0) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let packer = getParser_(theType.bits, theType.fp, theType.signed);\r\n  /** @type {number} */\r\n  let offset = Math.ceil(theType.bits / 8);\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let start = index;\r\n  for (let valuesLen = values.length; i < valuesLen; i++) {\r\n    index = packer.pack(buffer, values[i], index);\r\n  }\r\n  if (theType.be) {\r\n    endianness(buffer, offset, start, index);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpackArrayTo(\r\n    buffer, theType, output, start=0, end=buffer.length) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let parser = getParser_(theType.bits, theType.fp, theType.signed);\r\n  // getUnpackLen_ will adjust the end index according to the size\r\n  // of the input buffer and the byte offset or throw a error on bad\r\n  // end index if safe=true\r\n  end = getUnpackLen_(buffer, start, end, parser.offset);\r\n  if (theType.be) {\r\n    /** @type {!(Uint8Array|Array<number>)} */\r\n    let readBuffer = copyBuffer_(buffer);\r\n    if (theType.be) {\r\n      endianness(readBuffer, parser.offset, start, end);\r\n    }\r\n    unpack_(readBuffer, output, start, end, parser);\r\n  } else {\r\n    unpack_(buffer, output, start, end, parser);\r\n  }\r\n}\r\n\r\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packTo(value, theType, buffer, index=0) {\r\n  return packArrayTo([value], theType, buffer, index);\r\n}\r\n\r\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function pack(value, theType) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  packTo(value, theType, output, 0);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpack(buffer, theType, index=0) {\r\n  let output = [];\r\n  unpackArrayTo(buffer, theType, output,\r\n    index, index + Math.ceil(theType.bits / 8));\r\n  return output[0];\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {!Object} parser The parser.\r\n * @private\r\n */\r\nfunction unpack_(buffer, output, start, end, parser) {\r\n  /** @type {number} */\r\n  let offset = parser.offset;\r\n  for (let index = 0, j = start; j < end; j += offset, index++) {\r\n    output[index] = parser.unpack(buffer, j);\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a byte buffer as a Array or Uint8Array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @return {!(Uint8Array|Array<number>)}\r\n * @private\r\n */\r\nfunction copyBuffer_(buffer) {\r\n  return new Uint8Array(buffer);\r\n}\r\n\r\n/**\r\n * Adjust the end index according to the input buffer length and the\r\n * type offset.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @private\r\n */\r\nfunction getUnpackLen_(buffer, start, end, offset) {\r\n  /** @type {number} */\r\n  let extra = (end - start) % offset;\r\n  return end - extra;\r\n}\r\n\r\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\r\nfunction getParser_(bits, fp, signed) {\r\n  if (fp && bits == 32) {\r\n    return new FloatParser(8, 23);\r\n  } else if(fp && bits == 64) {\r\n    return new FloatParser(11, 52);\r\n  }\r\n  return new IntParser(bits, signed);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}