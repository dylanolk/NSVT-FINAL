{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileParser } from './wavefile-parser';\nimport { interleave, deInterleave } from './parsers/interleave';\nimport { validateNumChannels } from './validators/validate-num-channels';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\n\nexport class WaveFileCreator extends WaveFileParser {\n  constructor() {\n    super();\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\n\n    this.bitDepth = '0';\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n\n    this.dataType = {\n      bits: 0,\n      be: false\n    };\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\n\n    this.WAV_AUDIO_FORMATS = {\n      '4': 17,\n      '8': 1,\n      '8a': 6,\n      '8m': 7,\n      '16': 1,\n      '24': 1,\n      '32': 1,\n      '32f': 3,\n      '64': 3\n    };\n  }\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\n\n\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\n    options = options || {}; // reset all chunks\n\n    this.clearHeaders();\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n  }\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\n\n\n  fromBuffer(wavBuffer) {\n    let samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super.fromBuffer(wavBuffer, samples);\n    this.bitDepthFromFmt_();\n    this.updateDataType_();\n  }\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\n\n\n  toBuffer() {\n    this.validateWavHeader_();\n    return super.toBuffer();\n  }\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\n\n\n  getSamples() {\n    let interleaved = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let OutputObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float64Array;\n\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\n    let samples = new OutputObject(this.data.samples.length / (this.dataType.bits / 8)); // Unpack all the samples\n\n    unpackArrayTo(this.data.samples, this.dataType, samples, 0, this.data.samples.length);\n\n    if (!interleaved && this.fmt.numChannels > 1) {\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\n    }\n\n    return samples;\n  }\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\n\n\n  getSample(index) {\n    index = index * (this.dataType.bits / 8);\n\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\n      throw new Error('Range error');\n    }\n\n    return unpack(this.data.samples.slice(index, index + this.dataType.bits / 8), this.dataType);\n  }\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\n\n\n  setSample(index, sample) {\n    index = index * (this.dataType.bits / 8);\n\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\n      throw new Error('Range error');\n    }\n\n    packTo(sample, this.dataType, this.data.samples, index, true);\n  }\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\n\n\n  getiXML() {\n    return this.iXML.value;\n  }\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\n\n\n  setiXML(iXMLValue) {\n    if (typeof iXMLValue !== 'string') {\n      throw new TypeError('iXML value must be a string.');\n    }\n\n    this.iXML.value = iXMLValue;\n    this.iXML.chunkId = 'iXML';\n  }\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\n\n\n  get_PMX() {\n    return this._PMX.value;\n  }\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\n\n\n  set_PMX(_PMXValue) {\n    if (typeof _PMXValue !== 'string') {\n      throw new TypeError('_PMX value must be a string.');\n    }\n\n    this._PMX.value = _PMXValue;\n    this._PMX.chunkId = '_PMX';\n  }\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\n\n\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\n    if (!options.container) {\n      options.container = 'RIFF';\n    }\n\n    this.container = options.container;\n    this.bitDepth = bitDepthCode;\n    samples = interleave(samples);\n    this.updateDataType_();\n    /** @type {number} */\n\n    let numBytes = this.dataType.bits / 8;\n    this.data.samples = new Uint8Array(samples.length * numBytes);\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\n    this.makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, this.data.samples.length, options);\n    this.data.chunkId = 'data';\n    this.data.chunkSize = this.data.samples.length;\n    this.validateWavHeader_();\n  }\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n\n\n  makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    if (bitDepthCode == '4') {\n      this.createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\n      this.createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else if (Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 || numChannels > 2) {\n      this.createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else {\n      this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    }\n  }\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n\n\n  createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.container = options.container;\n    this.chunkSize = 36 + samplesLength;\n    this.format = 'WAVE';\n    this.bitDepth = bitDepthCode;\n    this.fmt = {\n      chunkId: 'fmt ',\n      chunkSize: 16,\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\n      numChannels: numChannels,\n      sampleRate: sampleRate,\n      byteRate: numChannels * numBytes * sampleRate,\n      blockAlign: numChannels * numBytes,\n      bitsPerSample: parseInt(bitDepthCode, 10),\n      cbSize: 0,\n      validBitsPerSample: 0,\n      dwChannelMask: 0,\n      subformat: []\n    };\n  }\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n\n\n  createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 40 + samplesLength;\n    this.fmt.chunkSize = 20;\n    this.fmt.byteRate = 4055;\n    this.fmt.blockAlign = 256;\n    this.fmt.bitsPerSample = 4;\n    this.fmt.cbSize = 2;\n    this.fmt.validBitsPerSample = 505;\n    this.fact = {\n      chunkId: 'fact',\n      chunkSize: 4,\n      dwSampleLength: samplesLength * 2\n    };\n  }\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n\n\n  createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 36 + 24 + samplesLength;\n    this.fmt.chunkSize = 40;\n    this.fmt.bitsPerSample = (parseInt(bitDepthCode, 10) - 1 | 7) + 1;\n    this.fmt.cbSize = 22;\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels); // subformat 128-bit GUID as 4 32-bit values\n    // only supports uncompressed integer PCM samples\n\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\n  }\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n\n\n  createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 40 + samplesLength;\n    this.fmt.chunkSize = 20;\n    this.fmt.cbSize = 2;\n    this.fmt.validBitsPerSample = 8;\n    this.fact = {\n      chunkId: 'fact',\n      chunkSize: 4,\n      dwSampleLength: samplesLength\n    };\n  }\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\n\n\n  bitDepthFromFmt_() {\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\n      this.bitDepth = '32f';\n    } else if (this.fmt.audioFormat === 6) {\n      this.bitDepth = '8a';\n    } else if (this.fmt.audioFormat === 7) {\n      this.bitDepth = '8m';\n    } else {\n      this.bitDepth = this.fmt.bitsPerSample.toString();\n    }\n  }\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\n\n\n  validateBitDepth_() {\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\n      if (parseInt(this.bitDepth, 10) > 8 && parseInt(this.bitDepth, 10) < 54) {\n        return true;\n      }\n\n      throw new Error('Invalid bit depth.');\n    }\n\n    return true;\n  }\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\n\n\n  updateDataType_() {\n    this.dataType = {\n      bits: (parseInt(this.bitDepth, 10) - 1 | 7) + 1,\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\n      signed: this.bitDepth != '8',\n      be: this.container == 'RIFX'\n    };\n\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n      this.dataType.bits = 8;\n      this.dataType.signed = false;\n    }\n  }\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\n\n\n  validateWavHeader_() {\n    this.validateBitDepth_();\n\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\n      throw new Error('Invalid number of channels.');\n    }\n\n    if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\n      throw new Error('Invalid sample rate.');\n    }\n  }\n\n}\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\n\nfunction dwChannelMask_(numChannels) {\n  /** @type {number} */\n  let mask = 0; // mono = FC\n\n  if (numChannels === 1) {\n    mask = 0x4; // stereo = FL, FR\n  } else if (numChannels === 2) {\n    mask = 0x3; // quad = FL, FR, BL, BR\n  } else if (numChannels === 4) {\n    mask = 0x33; // 5.1 = FL, FR, FC, LF, BL, BR\n  } else if (numChannels === 6) {\n    mask = 0x3F; // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\n  } else if (numChannels === 8) {\n    mask = 0x63F;\n  }\n\n  return mask;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-creator.js"],"names":["WaveFileParser","interleave","deInterleave","validateNumChannels","validateSampleRate","packArrayTo","unpackArrayTo","packTo","unpack","WaveFileCreator","constructor","bitDepth","dataType","bits","be","WAV_AUDIO_FORMATS","fromScratch","numChannels","sampleRate","bitDepthCode","samples","options","clearHeaders","newWavFile_","fromBuffer","wavBuffer","bitDepthFromFmt_","updateDataType_","toBuffer","validateWavHeader_","getSamples","interleaved","OutputObject","Float64Array","data","length","fmt","getSample","index","Error","slice","setSample","sample","getiXML","iXML","value","setiXML","iXMLValue","TypeError","chunkId","get_PMX","_PMX","set_PMX","_PMXValue","container","numBytes","Uint8Array","makeWavHeader_","chunkSize","samplesLength","createADPCMHeader_","createALawMulawHeader_","Object","keys","indexOf","createExtensibleHeader_","createPCMHeader_","format","audioFormat","byteRate","blockAlign","bitsPerSample","parseInt","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","dwChannelMask_","toString","validateBitDepth_","fp","signed","mask"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileParser } from './wavefile-parser';\r\nimport { interleave, deInterleave } from './parsers/interleave';\r\nimport { validateNumChannels } from './validators/validate-num-channels'; \r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\r\nexport class WaveFileCreator extends WaveFileParser {\r\n\r\n  constructor() {\r\n    super();\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.dataType = {bits: 0, be: false};\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\r\n    this.WAV_AUDIO_FORMATS = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    options = options || {};\r\n    // reset all chunks\r\n    this.clearHeaders();\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    super.fromBuffer(wavBuffer, samples);\r\n    this.bitDepthFromFmt_();\r\n    this.updateDataType_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\r\n  toBuffer() {\r\n    this.validateWavHeader_();\r\n    return super.toBuffer();\r\n  }\r\n\r\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\r\n  getSamples(interleaved=false, OutputObject=Float64Array) {\r\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = new OutputObject(\r\n      this.data.samples.length / (this.dataType.bits / 8));\r\n    // Unpack all the samples\r\n    unpackArrayTo(this.data.samples, this.dataType, samples,\r\n      0, this.data.samples.length);\r\n    if (!interleaved && this.fmt.numChannels > 1) {\r\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\r\n    }\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  getSample(index) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    return unpack(\r\n      this.data.samples.slice(index, index + this.dataType.bits / 8),\r\n      this.dataType);\r\n  }\r\n\r\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  setSample(index, sample) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    packTo(sample, this.dataType, this.data.samples, index, true);\r\n  }\r\n\r\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\r\n  getiXML() {\r\n    return this.iXML.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  setiXML(iXMLValue) {\r\n    if (typeof iXMLValue !== 'string') {\r\n      throw new TypeError('iXML value must be a string.');\r\n    }\r\n    this.iXML.value = iXMLValue;\r\n    this.iXML.chunkId = 'iXML';\r\n  }\r\n\r\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\r\n  get_PMX() {\r\n    return this._PMX.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  set_PMX(_PMXValue) {\r\n    if (typeof _PMXValue !== 'string') {\r\n      throw new TypeError('_PMX value must be a string.');\r\n    }\r\n    this._PMX.value = _PMXValue;\r\n    this._PMX.chunkId = '_PMX';\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    if (!options.container) {\r\n      options.container = 'RIFF';\r\n    }\r\n    this.container = options.container;\r\n    this.bitDepth = bitDepthCode;\r\n    samples = interleave(samples);\r\n    this.updateDataType_();\r\n    /** @type {number} */\r\n    let numBytes = this.dataType.bits / 8;\r\n    this.data.samples = new Uint8Array(samples.length * numBytes);\r\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\r\n    this.makeWavHeader_(\r\n      bitDepthCode, numChannels, sampleRate,\r\n      numBytes, this.data.samples.length, options);\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length;\r\n    this.validateWavHeader_();\r\n  }\r\n\r\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  makeWavHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    if (bitDepthCode == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if(Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 ||\r\n        numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else {\r\n      this.createPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);      \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.container = options.container;\r\n    this.chunkSize = 36 + samplesLength;\r\n    this.format = 'WAVE';\r\n    this.bitDepth = bitDepthCode;\r\n    this.fmt = {\r\n      chunkId: 'fmt ',\r\n      chunkSize: 16,\r\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\r\n      numChannels: numChannels,\r\n      sampleRate: sampleRate,\r\n      byteRate: (numChannels * numBytes) * sampleRate,\r\n      blockAlign: numChannels * numBytes,\r\n      bitsPerSample: parseInt(bitDepthCode, 10),\r\n      cbSize: 0,\r\n      validBitsPerSample: 0,\r\n      dwChannelMask: 0,\r\n      subformat: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength * 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 36 + 24 + samplesLength;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepthCode, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\r\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels);\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat === 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat === 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\r\n  updateDataType_() {\r\n    this.dataType = {\r\n      bits: ((parseInt(this.bitDepth, 10) - 1) | 7) + 1,\r\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\r\n      signed: this.bitDepth != '8',\r\n      be: this.container == 'RIFX'\r\n    };\r\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1 ) {\r\n      this.dataType.bits = 8;\r\n      this.dataType.signed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\r\n  validateWavHeader_() {\r\n    this.validateBitDepth_();\r\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\r\nfunction dwChannelMask_(numChannels) {\r\n  /** @type {number} */\r\n  let mask = 0;\r\n  // mono = FC\r\n  if (numChannels === 1) {\r\n    mask = 0x4;\r\n  // stereo = FL, FR\r\n  } else if (numChannels === 2) {\r\n    mask = 0x3;\r\n  // quad = FL, FR, BL, BR\r\n  } else if (numChannels === 4) {\r\n    mask = 0x33;\r\n  // 5.1 = FL, FR, FC, LF, BL, BR\r\n  } else if (numChannels === 6) {\r\n    mask = 0x3F;\r\n  // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n  } else if (numChannels === 8) {\r\n    mask = 0x63F;\r\n  }\r\n  return mask;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}