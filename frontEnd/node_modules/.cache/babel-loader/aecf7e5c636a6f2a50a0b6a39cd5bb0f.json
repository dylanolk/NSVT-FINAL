{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { RIFFFile } from './riff-file';\nimport { unpackString, unpack } from './parsers/binary';\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\n\nexport class WaveFileReader extends RIFFFile {\n  constructor() {\n    super(); // Include 'RF64' as a supported container format\n\n    this.supported_containers.push('RF64');\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.fmt = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      audioFormat: 0,\n\n      /** @type {number} */\n      numChannels: 0,\n\n      /** @type {number} */\n      sampleRate: 0,\n\n      /** @type {number} */\n      byteRate: 0,\n\n      /** @type {number} */\n      blockAlign: 0,\n\n      /** @type {number} */\n      bitsPerSample: 0,\n\n      /** @type {number} */\n      cbSize: 0,\n\n      /** @type {number} */\n      validBitsPerSample: 0,\n\n      /** @type {number} */\n      dwChannelMask: 0,\n\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\n      subformat: []\n    };\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.fact = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwSampleLength: 0\n    };\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.cue = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwCuePoints: 0,\n\n      /** @type {!Array<!Object>} */\n      points: []\n    };\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.smpl = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwManufacturer: 0,\n\n      /** @type {number} */\n      dwProduct: 0,\n\n      /** @type {number} */\n      dwSamplePeriod: 0,\n\n      /** @type {number} */\n      dwMIDIUnityNote: 0,\n\n      /** @type {number} */\n      dwMIDIPitchFraction: 0,\n\n      /** @type {number} */\n      dwSMPTEFormat: 0,\n\n      /** @type {number} */\n      dwSMPTEOffset: 0,\n\n      /** @type {number} */\n      dwNumSampleLoops: 0,\n\n      /** @type {number} */\n      dwSamplerData: 0,\n\n      /** @type {!Array<!Object>} */\n      loops: []\n    };\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.bext = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      description: '',\n      //256\n\n      /** @type {string} */\n      originator: '',\n      //32\n\n      /** @type {string} */\n      originatorReference: '',\n      //32\n\n      /** @type {string} */\n      originationDate: '',\n      //10\n\n      /** @type {string} */\n      originationTime: '',\n      //8\n\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\n      timeReference: [0, 0],\n\n      /** @type {number} */\n      version: 0,\n      //WORD\n\n      /** @type {string} */\n      UMID: '',\n      // 64 chars\n\n      /** @type {number} */\n      loudnessValue: 0,\n      //WORD\n\n      /** @type {number} */\n      loudnessRange: 0,\n      //WORD\n\n      /** @type {number} */\n      maxTruePeakLevel: 0,\n      //WORD\n\n      /** @type {number} */\n      maxMomentaryLoudness: 0,\n      //WORD\n\n      /** @type {number} */\n      maxShortTermLoudness: 0,\n      //WORD\n\n      /** @type {string} */\n      reserved: '',\n      //180\n\n      /** @type {string} */\n      codingHistory: '' // string, unlimited\n\n    };\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.iXML = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.ds64 = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      riffSizeHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      riffSizeLow: 0,\n      // DWORD\n\n      /** @type {number} */\n      dataSizeHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      dataSizeLow: 0,\n      // DWORD\n\n      /** @type {number} */\n      originationTime: 0,\n      // DWORD\n\n      /** @type {number} */\n      sampleCountHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      sampleCountLow: 0 // DWORD\n\n      /** @type {number} */\n      //'tableLength': 0, // DWORD\n\n      /** @type {!Array<number>} */\n      //'table': []\n\n    };\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.data = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {!Uint8Array} */\n      samples: new Uint8Array(0)\n    };\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\n\n    this.LIST = [];\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this.junk = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {!Array<number>} */\n      chunkData: []\n    };\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    this._PMX = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\n\n    this.uInt16 = {\n      bits: 16,\n      be: false,\n      signed: false,\n      fp: false\n    };\n  }\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\n\n\n  fromBuffer(wavBuffer) {\n    let samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // Always should reset the chunks when reading from a buffer\n    this.clearHeaders();\n    this.setSignature(wavBuffer);\n    this.uInt16.be = this.uInt32.be;\n\n    if (this.format != 'WAVE') {\n      throw Error('Could not find the \"WAVE\" format identifier');\n    }\n\n    this.readDs64Chunk_(wavBuffer);\n    this.readFmtChunk_(wavBuffer);\n    this.readFactChunk_(wavBuffer);\n    this.readBextChunk_(wavBuffer);\n    this.readiXMLChunk_(wavBuffer);\n    this.readCueChunk_(wavBuffer);\n    this.readSmplChunk_(wavBuffer);\n    this.readDataChunk_(wavBuffer, samples);\n    this.readJunkChunk_(wavBuffer);\n    this.readLISTChunk_(wavBuffer);\n    this.read_PMXChunk_(wavBuffer);\n  }\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\n\n\n  clearHeaders() {\n    /** @type {!Object} */\n    let tmpWav = new WaveFileReader();\n    Object.assign(this.fmt, tmpWav.fmt);\n    Object.assign(this.fact, tmpWav.fact);\n    Object.assign(this.cue, tmpWav.cue);\n    Object.assign(this.smpl, tmpWav.smpl);\n    Object.assign(this.bext, tmpWav.bext);\n    Object.assign(this.iXML, tmpWav.iXML);\n    Object.assign(this.ds64, tmpWav.ds64);\n    Object.assign(this.data, tmpWav.data);\n    this.LIST = [];\n    Object.assign(this.junk, tmpWav.junk);\n    Object.assign(this._PMX, tmpWav._PMX);\n  }\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\n\n\n  readFmtChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('fmt ');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.fmt.chunkId = chunk.chunkId;\n      this.fmt.chunkSize = chunk.chunkSize;\n      this.fmt.audioFormat = this.readUInt16_(buffer);\n      this.fmt.numChannels = this.readUInt16_(buffer);\n      this.fmt.sampleRate = this.readUInt32(buffer);\n      this.fmt.byteRate = this.readUInt32(buffer);\n      this.fmt.blockAlign = this.readUInt16_(buffer);\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\n      this.readFmtExtension_(buffer);\n    } else {\n      throw Error('Could not find the \"fmt \" chunk');\n    }\n  }\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readFmtExtension_(buffer) {\n    if (this.fmt.chunkSize > 16) {\n      this.fmt.cbSize = this.readUInt16_(buffer);\n\n      if (this.fmt.chunkSize > 18) {\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\n\n        if (this.fmt.chunkSize > 20) {\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\n          this.fmt.subformat = [this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer)];\n        }\n      }\n    }\n  }\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readFactChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('fact');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.fact.chunkId = chunk.chunkId;\n      this.fact.chunkSize = chunk.chunkSize;\n      this.fact.dwSampleLength = this.readUInt32(buffer);\n    }\n  }\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readCueChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('cue ');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.cue.chunkId = chunk.chunkId;\n      this.cue.chunkSize = chunk.chunkSize;\n      this.cue.dwCuePoints = this.readUInt32(buffer);\n\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\n        this.cue.points.push({\n          dwName: this.readUInt32(buffer),\n          dwPosition: this.readUInt32(buffer),\n          fccChunk: this.readString(buffer, 4),\n          dwChunkStart: this.readUInt32(buffer),\n          dwBlockStart: this.readUInt32(buffer),\n          dwSampleOffset: this.readUInt32(buffer)\n        });\n      }\n    }\n  }\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readSmplChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('smpl');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.smpl.chunkId = chunk.chunkId;\n      this.smpl.chunkSize = chunk.chunkSize;\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\n      this.smpl.dwProduct = this.readUInt32(buffer);\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\n\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n        this.smpl.loops.push({\n          dwName: this.readUInt32(buffer),\n          dwType: this.readUInt32(buffer),\n          dwStart: this.readUInt32(buffer),\n          dwEnd: this.readUInt32(buffer),\n          dwFraction: this.readUInt32(buffer),\n          dwPlayCount: this.readUInt32(buffer)\n        });\n      }\n    }\n  }\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\n\n\n  readDataChunk_(buffer, samples) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('data');\n\n    if (chunk) {\n      this.data.chunkId = 'data';\n      this.data.chunkSize = chunk.chunkSize;\n\n      if (samples) {\n        this.data.samples = buffer.slice(chunk.chunkData.start, chunk.chunkData.end);\n      }\n    } else {\n      throw Error('Could not find the \"data\" chunk');\n    }\n  }\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readBextChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('bext');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.bext.chunkId = chunk.chunkId;\n      this.bext.chunkSize = chunk.chunkSize;\n      this.bext.description = this.readString(buffer, 256);\n      this.bext.originator = this.readString(buffer, 32);\n      this.bext.originatorReference = this.readString(buffer, 32);\n      this.bext.originationDate = this.readString(buffer, 10);\n      this.bext.originationTime = this.readString(buffer, 8);\n      this.bext.timeReference = [this.readUInt32(buffer), this.readUInt32(buffer)];\n      this.bext.version = this.readUInt16_(buffer);\n      this.bext.UMID = this.readString(buffer, 64);\n      this.bext.loudnessValue = this.readUInt16_(buffer);\n      this.bext.loudnessRange = this.readUInt16_(buffer);\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\n      this.bext.reserved = this.readString(buffer, 180);\n      this.bext.codingHistory = this.readString(buffer, this.bext.chunkSize - 602);\n    }\n  }\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readiXMLChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('iXML');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.iXML.chunkId = chunk.chunkId;\n      this.iXML.chunkSize = chunk.chunkSize;\n      this.iXML.value = unpackString(buffer, this.head, this.head + this.iXML.chunkSize);\n    }\n  }\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\n\n\n  readDs64Chunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('ds64');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.ds64.chunkId = chunk.chunkId;\n      this.ds64.chunkSize = chunk.chunkSize;\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\n      this.ds64.originationTime = this.readUInt32(buffer);\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\n      this.ds64.sampleCountLow = this.readUInt32(buffer); //if (wav.ds64.chunkSize > 28) {\n      //  wav.ds64.tableLength = unpack(\n      //    chunkData.slice(28, 32), uInt32_);\n      //  wav.ds64.table = chunkData.slice(\n      //     32, 32 + wav.ds64.tableLength);\n      //}\n    } else {\n      if (this.container == 'RF64') {\n        throw Error('Could not find the \"ds64\" chunk');\n      }\n    }\n  }\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readLISTChunk_(buffer) {\n    /** @type {?Object} */\n    let listChunks = this.findChunk('LIST', true);\n\n    if (listChunks !== null) {\n      for (let j = 0; j < listChunks.length; j++) {\n        /** @type {!Object} */\n        let subChunk = listChunks[j];\n        this.LIST.push({\n          chunkId: subChunk.chunkId,\n          chunkSize: subChunk.chunkSize,\n          format: subChunk.format,\n          subChunks: []\n        });\n\n        for (let x = 0; x < subChunk.subChunks.length; x++) {\n          this.readLISTSubChunks_(subChunk.subChunks[x], subChunk.format, buffer);\n        }\n      }\n    }\n  }\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readLISTSubChunks_(subChunk, format, buffer) {\n    if (format == 'adtl') {\n      if (['labl', 'note', 'ltxt'].indexOf(subChunk.chunkId) > -1) {\n        this.readLISTadtlSubChunks_(buffer, subChunk);\n      } // RIFF INFO tags like ICRD, ISFT, ICMT\n\n    } else if (format == 'INFO') {\n      this.readLISTINFOSubChunks_(buffer, subChunk);\n    }\n  }\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\n\n\n  readLISTadtlSubChunks_(buffer, subChunk) {\n    this.head = subChunk.chunkData.start;\n    /** @type {!Object<string, string|number>} */\n\n    let item = {\n      chunkId: subChunk.chunkId,\n      chunkSize: subChunk.chunkSize,\n      dwName: this.readUInt32(buffer)\n    };\n\n    if (subChunk.chunkId == 'ltxt') {\n      item.dwSampleLength = this.readUInt32(buffer);\n      item.dwPurposeID = this.readUInt32(buffer);\n      item.dwCountry = this.readUInt16_(buffer);\n      item.dwLanguage = this.readUInt16_(buffer);\n      item.dwDialect = this.readUInt16_(buffer);\n      item.dwCodePage = this.readUInt16_(buffer);\n      item.value = ''; // kept for compatibility\n    } else {\n      item.value = this.readZSTR_(buffer, this.head);\n    }\n\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\n  }\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\n\n\n  readLISTINFOSubChunks_(buffer, subChunk) {\n    this.head = subChunk.chunkData.start;\n    this.LIST[this.LIST.length - 1].subChunks.push({\n      chunkId: subChunk.chunkId,\n      chunkSize: subChunk.chunkSize,\n      value: this.readZSTR_(buffer, this.head)\n    });\n  }\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  readJunkChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('junk');\n\n    if (chunk) {\n      this.junk = {\n        chunkId: chunk.chunkId,\n        chunkSize: chunk.chunkSize,\n        chunkData: [].slice.call(buffer.slice(chunk.chunkData.start, chunk.chunkData.end))\n      };\n    }\n  }\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n\n\n  read_PMXChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('_PMX');\n\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this._PMX.chunkId = chunk.chunkId;\n      this._PMX.chunkSize = chunk.chunkSize;\n      this._PMX.value = unpackString(buffer, this.head, this.head + this._PMX.chunkSize);\n    }\n  }\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\n\n\n  readZSTR_(bytes) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (let i = index; i < bytes.length; i++) {\n      this.head++;\n\n      if (bytes[i] === 0) {\n        break;\n      }\n    }\n\n    return unpackString(bytes, index, this.head - 1);\n  }\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\n\n\n  readUInt16_(bytes) {\n    /** @type {number} */\n    let value = unpack(bytes, this.uInt16, this.head);\n    this.head += 2;\n    return value;\n  }\n\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-reader.js"],"names":["RIFFFile","unpackString","unpack","WaveFileReader","constructor","supported_containers","push","fmt","chunkId","chunkSize","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","cue","dwCuePoints","points","smpl","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","bext","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","codingHistory","iXML","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","data","samples","Uint8Array","LIST","junk","chunkData","_PMX","uInt16","bits","be","signed","fp","fromBuffer","wavBuffer","clearHeaders","setSignature","uInt32","format","Error","readDs64Chunk_","readFmtChunk_","readFactChunk_","readBextChunk_","readiXMLChunk_","readCueChunk_","readSmplChunk_","readDataChunk_","readJunkChunk_","readLISTChunk_","read_PMXChunk_","tmpWav","Object","assign","buffer","chunk","findChunk","head","start","readUInt16_","readUInt32","readFmtExtension_","i","dwName","dwPosition","fccChunk","readString","dwChunkStart","dwBlockStart","dwSampleOffset","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","slice","end","container","listChunks","j","length","subChunk","subChunks","x","readLISTSubChunks_","indexOf","readLISTadtlSubChunks_","readLISTINFOSubChunks_","item","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","readZSTR_","call","bytes","index"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { RIFFFile } from './riff-file';\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\r\nexport class WaveFileReader extends RIFFFile {\r\n\r\n  constructor() {\r\n    super();\r\n    // Include 'RF64' as a supported container format\r\n    this.supported_containers.push('RF64');\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fmt = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      audioFormat: 0,\r\n      /** @type {number} */\r\n      numChannels: 0,\r\n      /** @type {number} */\r\n      sampleRate: 0,\r\n      /** @type {number} */\r\n      byteRate: 0,\r\n      /** @type {number} */\r\n      blockAlign: 0,\r\n      /** @type {number} */\r\n      bitsPerSample: 0,\r\n      /** @type {number} */\r\n      cbSize: 0,\r\n      /** @type {number} */\r\n      validBitsPerSample: 0,\r\n      /** @type {number} */\r\n      dwChannelMask: 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\r\n      subformat: []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fact = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwSampleLength: 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.cue = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwCuePoints: 0,\r\n      /** @type {!Array<!Object>} */\r\n      points: [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.smpl = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwManufacturer: 0,\r\n      /** @type {number} */\r\n      dwProduct: 0,\r\n      /** @type {number} */\r\n      dwSamplePeriod: 0,\r\n      /** @type {number} */\r\n      dwMIDIUnityNote: 0,\r\n      /** @type {number} */\r\n      dwMIDIPitchFraction: 0,\r\n      /** @type {number} */\r\n      dwSMPTEFormat: 0,\r\n      /** @type {number} */\r\n      dwSMPTEOffset: 0,\r\n      /** @type {number} */\r\n      dwNumSampleLoops: 0,\r\n      /** @type {number} */\r\n      dwSamplerData: 0,\r\n      /** @type {!Array<!Object>} */\r\n      loops: []\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.bext = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      description: '', //256\r\n      /** @type {string} */\r\n      originator: '', //32\r\n      /** @type {string} */\r\n      originatorReference: '', //32\r\n      /** @type {string} */\r\n      originationDate: '', //10\r\n      /** @type {string} */\r\n      originationTime: '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\r\n      timeReference: [0, 0],\r\n      /** @type {number} */\r\n      version: 0, //WORD\r\n      /** @type {string} */\r\n      UMID: '', // 64 chars\r\n      /** @type {number} */\r\n      loudnessValue: 0, //WORD\r\n      /** @type {number} */\r\n      loudnessRange: 0, //WORD\r\n      /** @type {number} */\r\n      maxTruePeakLevel: 0, //WORD\r\n      /** @type {number} */\r\n      maxMomentaryLoudness: 0, //WORD\r\n      /** @type {number} */\r\n      maxShortTermLoudness: 0, //WORD\r\n      /** @type {string} */\r\n      reserved: '', //180\r\n      /** @type {string} */\r\n      codingHistory: '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.iXML = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      riffSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      riffSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      originationTime: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountLow: 0 // DWORD\r\n      /** @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.data = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Uint8Array} */\r\n      samples: new Uint8Array(0)\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.junk = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Array<number>} */\r\n      chunkData: []\r\n    };\r\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this._PMX = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt16 = {bits: 16, be: false, signed: false, fp: false};\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    // Always should reset the chunks when reading from a buffer\r\n    this.clearHeaders();\r\n    this.setSignature(wavBuffer);\r\n    this.uInt16.be = this.uInt32.be;\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n    this.readDs64Chunk_(wavBuffer);\r\n    this.readFmtChunk_(wavBuffer);\r\n    this.readFactChunk_(wavBuffer);\r\n    this.readBextChunk_(wavBuffer);\r\n    this.readiXMLChunk_(wavBuffer);\r\n    this.readCueChunk_(wavBuffer);\r\n    this.readSmplChunk_(wavBuffer);\r\n    this.readDataChunk_(wavBuffer, samples);\r\n    this.readJunkChunk_(wavBuffer);\r\n    this.readLISTChunk_(wavBuffer);\r\n    this.read_PMXChunk_(wavBuffer);\r\n  }\r\n\r\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\r\n  clearHeaders() {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileReader();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.cue, tmpWav.cue);\r\n    Object.assign(this.smpl, tmpWav.smpl);\r\n    Object.assign(this.bext, tmpWav.bext);\r\n    Object.assign(this.iXML, tmpWav.iXML);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.LIST = [];\r\n    Object.assign(this.junk, tmpWav.junk);\r\n    Object.assign(this._PMX, tmpWav._PMX);\r\n  }\r\n  \r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fmt ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fmt.chunkId = chunk.chunkId;\r\n      this.fmt.chunkSize = chunk.chunkSize;\r\n      this.fmt.audioFormat = this.readUInt16_(buffer);\r\n      this.fmt.numChannels = this.readUInt16_(buffer);\r\n      this.fmt.sampleRate = this.readUInt32(buffer);\r\n      this.fmt.byteRate = this.readUInt32(buffer);\r\n      this.fmt.blockAlign = this.readUInt16_(buffer);\r\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.readUInt16_(buffer);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\r\n          this.fmt.subformat = [\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fact');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fact.chunkId = chunk.chunkId;\r\n      this.fact.chunkSize = chunk.chunkSize;\r\n      this.fact.dwSampleLength = this.readUInt32(buffer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('cue ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.cue.chunkId = chunk.chunkId;\r\n      this.cue.chunkSize = chunk.chunkSize;\r\n      this.cue.dwCuePoints = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwPosition: this.readUInt32(buffer),\r\n          fccChunk: this.readString(buffer, 4),\r\n          dwChunkStart: this.readUInt32(buffer),\r\n          dwBlockStart: this.readUInt32(buffer),\r\n          dwSampleOffset: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('smpl');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.smpl.chunkId = chunk.chunkId;\r\n      this.smpl.chunkSize = chunk.chunkSize;\r\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\r\n      this.smpl.dwProduct = this.readUInt32(buffer);\r\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\r\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\r\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwType: this.readUInt32(buffer),\r\n          dwStart: this.readUInt32(buffer),\r\n          dwEnd: this.readUInt32(buffer),\r\n          dwFraction: this.readUInt32(buffer),\r\n          dwPlayCount: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, samples) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk.chunkSize;\r\n      if (samples) {\r\n        this.data.samples = buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end);\r\n      }\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('bext');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.bext.chunkId = chunk.chunkId;\r\n      this.bext.chunkSize = chunk.chunkSize;\r\n      this.bext.description = this.readString(buffer, 256);\r\n      this.bext.originator = this.readString(buffer, 32);\r\n      this.bext.originatorReference = this.readString(buffer, 32);\r\n      this.bext.originationDate = this.readString(buffer, 10);\r\n      this.bext.originationTime = this.readString(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.readUInt32(buffer),\r\n        this.readUInt32(buffer)];\r\n      this.bext.version = this.readUInt16_(buffer);\r\n      this.bext.UMID = this.readString(buffer, 64);\r\n      this.bext.loudnessValue = this.readUInt16_(buffer);\r\n      this.bext.loudnessRange = this.readUInt16_(buffer);\r\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\r\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\r\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\r\n      this.bext.reserved = this.readString(buffer, 180);\r\n      this.bext.codingHistory = this.readString(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readiXMLChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('iXML');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.iXML.chunkId = chunk.chunkId;\r\n      this.iXML.chunkSize = chunk.chunkSize;\r\n      this.iXML.value = unpackString(\r\n        buffer, this.head, this.head + this.iXML.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('ds64');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.ds64.chunkId = chunk.chunkId;\r\n      this.ds64.chunkSize = chunk.chunkSize;\r\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\r\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\r\n      this.ds64.originationTime = this.readUInt32(buffer);\r\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\r\n      this.ds64.sampleCountLow = this.readUInt32(buffer);\r\n      //if (wav.ds64.chunkSize > 28) {\r\n      //  wav.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  wav.ds64.table = chunkData.slice(\r\n      //     32, 32 + wav.ds64.tableLength);\r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk('LIST', true);\r\n    if (listChunks !== null) {\r\n      for (let j=0; j < listChunks.length; j++) {\r\n        /** @type {!Object} */\r\n        let subChunk = listChunks[j];\r\n        this.LIST.push({\r\n          chunkId: subChunk.chunkId,\r\n          chunkSize: subChunk.chunkSize,\r\n          format: subChunk.format,\r\n          subChunks: []});\r\n        for (let x=0; x<subChunk.subChunks.length; x++) {\r\n          this.readLISTSubChunks_(subChunk.subChunks[x],\r\n            subChunk.format, buffer);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk.chunkId) > -1) {\r\n        this.readLISTadtlSubChunks_(buffer, subChunk);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.readLISTINFOSubChunks_(buffer, subChunk);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTadtlSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    /** @type {!Object<string, string|number>} */\r\n    let item = {\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      dwName: this.readUInt32(buffer)\r\n    };\r\n    if (subChunk.chunkId == 'ltxt') {\r\n      item.dwSampleLength = this.readUInt32(buffer);\r\n      item.dwPurposeID = this.readUInt32(buffer);\r\n      item.dwCountry = this.readUInt16_(buffer);\r\n      item.dwLanguage = this.readUInt16_(buffer);\r\n      item.dwDialect = this.readUInt16_(buffer);\r\n      item.dwCodePage = this.readUInt16_(buffer);\r\n      item.value = ''; // kept for compatibility\r\n    } else {\r\n      item.value = this.readZSTR_(buffer, this.head);\r\n    }\r\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTINFOSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    this.LIST[this.LIST.length - 1].subChunks.push({\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      value: this.readZSTR_(buffer, this.head)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        chunkId: chunk.chunkId,\r\n        chunkSize: chunk.chunkSize,\r\n        chunkData: [].slice.call(buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  read_PMXChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('_PMX');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this._PMX.chunkId = chunk.chunkId;\r\n      this._PMX.chunkSize = chunk.chunkSize;\r\n      this._PMX.value = unpackString(\r\n        buffer, this.head, this.head + this._PMX.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    for (let i = index; i < bytes.length; i++) {\r\n      this.head++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n    }\r\n    return unpackString(bytes, index, this.head - 1);\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\r\n  readUInt16_(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt16, this.head);\r\n    this.head += 2;\r\n    return value;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}