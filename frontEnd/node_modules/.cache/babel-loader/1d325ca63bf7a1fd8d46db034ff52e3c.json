{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileTagEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileCreator } from './wavefile-creator';\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileCreator\r\n * @ignore\r\n */\n\nexport class WaveFileTagEditor extends WaveFileCreator {\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   */\n  getTag(tag) {\n    /** @type {!Object} */\n    let index = this.getTagIndex_(tag);\n\n    if (index.TAG !== null) {\n      return this.LIST[index.LIST].subChunks[index.TAG].value;\n    }\n\n    return null;\n  }\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   */\n\n\n  setTag(tag, value) {\n    tag = fixRIFFTag_(tag);\n    /** @type {!Object} */\n\n    let index = this.getTagIndex_(tag);\n\n    if (index.TAG !== null) {\n      this.LIST[index.LIST].subChunks[index.TAG].chunkSize = value.length + 1;\n      this.LIST[index.LIST].subChunks[index.TAG].value = value;\n    } else if (index.LIST !== null) {\n      this.LIST[index.LIST].subChunks.push({\n        chunkId: tag,\n        chunkSize: value.length + 1,\n        value: value\n      });\n    } else {\n      this.LIST.push({\n        chunkId: 'LIST',\n        chunkSize: 8 + value.length + 1,\n        format: 'INFO',\n        subChunks: []\n      });\n      this.LIST[this.LIST.length - 1].subChunks.push({\n        chunkId: tag,\n        chunkSize: value.length + 1,\n        value: value\n      });\n    }\n  }\n  /**\r\n   * Remove a RIFF tag from the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   */\n\n\n  deleteTag(tag) {\n    /** @type {!Object} */\n    let index = this.getTagIndex_(tag);\n\n    if (index.TAG !== null) {\n      this.LIST[index.LIST].subChunks.splice(index.TAG, 1);\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Return a Object<tag, value> with the RIFF tags in the file.\r\n   * @return {!Object<string, string>} The file tags.\r\n   */\n\n\n  listTags() {\n    /** @type {?number} */\n    let index = this.getLISTIndex('INFO');\n    /** @type {!Object} */\n\n    let tags = {};\n\n    if (index !== null) {\n      for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\n        tags[this.LIST[index].subChunks[i].chunkId] = this.LIST[index].subChunks[i].value;\n      }\n    }\n\n    return tags;\n  }\n  /**\r\n   * Return the index of a list by its type.\r\n   * @param {string} listType The list type ('adtl', 'INFO')\r\n   * @return {?number}\r\n   * @protected\r\n   */\n\n\n  getLISTIndex(listType) {\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\n      if (this.LIST[i].format == listType) {\n        return i;\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\n\n\n  getTagIndex_(tag) {\n    /** @type {!Object<string, ?number>} */\n    let index = {\n      LIST: null,\n      TAG: null\n    };\n\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\n      if (this.LIST[i].format == 'INFO') {\n        index.LIST = i;\n\n        for (let j = 0, subLen = this.LIST[i].subChunks.length; j < subLen; j++) {\n          if (this.LIST[i].subChunks[j].chunkId == tag) {\n            index.TAG = j;\n            break;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return index;\n  }\n\n}\n/**\r\n * Fix a RIFF tag format if possible, throw an error otherwise.\r\n * @param {string} tag The tag name.\r\n * @return {string} The tag name in proper fourCC format.\r\n * @private\r\n */\n\nfunction fixRIFFTag_(tag) {\n  if (tag.constructor !== String) {\n    throw new Error('Invalid tag name.');\n  } else if (tag.length < 4) {\n    for (let i = 0, len = 4 - tag.length; i < len; i++) {\n      tag += ' ';\n    }\n  }\n\n  return tag;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-tag-editor.js"],"names":["WaveFileCreator","WaveFileTagEditor","getTag","tag","index","getTagIndex_","TAG","LIST","subChunks","value","setTag","fixRIFFTag_","chunkSize","length","push","chunkId","format","deleteTag","splice","listTags","getLISTIndex","tags","i","len","listType","j","subLen","constructor","String","Error"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileTagEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileCreator } from './wavefile-creator';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileCreator\r\n * @ignore\r\n */\r\nexport class WaveFileTagEditor extends WaveFileCreator {\r\n\r\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   */\r\n  getTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      return this.LIST[index.LIST].subChunks[index.TAG].value;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   */\r\n  setTag(tag, value) {\r\n    tag = fixRIFFTag_(tag);\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks[index.TAG].chunkSize =\r\n        value.length + 1;\r\n      this.LIST[index.LIST].subChunks[index.TAG].value = value;\r\n    } else if (index.LIST !== null) {\r\n      this.LIST[index.LIST].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    } else {\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 8 + value.length + 1,\r\n        format: 'INFO',\r\n        subChunks: []});\r\n      this.LIST[this.LIST.length - 1].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a RIFF tag from the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   */\r\n  deleteTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks.splice(index.TAG, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return a Object<tag, value> with the RIFF tags in the file.\r\n   * @return {!Object<string, string>} The file tags.\r\n   */\r\n  listTags() {\r\n    /** @type {?number} */\r\n    let index = this.getLISTIndex('INFO');\r\n    /** @type {!Object} */\r\n    let tags = {};\r\n    if (index !== null) {\r\n      for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n        tags[this.LIST[index].subChunks[i].chunkId] =\r\n          this.LIST[index].subChunks[i].value;\r\n      }\r\n    }\r\n    return tags;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a list by its type.\r\n   * @param {string} listType The list type ('adtl', 'INFO')\r\n   * @return {?number}\r\n   * @protected\r\n   */\r\n  getLISTIndex(listType) {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == listType) {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\r\n  getTagIndex_(tag) {\r\n    /** @type {!Object<string, ?number>} */\r\n    let index = {LIST: null, TAG: null};\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'INFO') {\r\n        index.LIST = i;\r\n        for (let j=0, subLen = this.LIST[i].subChunks.length; j < subLen; j++) {\r\n          if (this.LIST[i].subChunks[j].chunkId == tag) {\r\n            index.TAG = j;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n}\r\n\r\n/**\r\n * Fix a RIFF tag format if possible, throw an error otherwise.\r\n * @param {string} tag The tag name.\r\n * @return {string} The tag name in proper fourCC format.\r\n * @private\r\n */\r\nfunction fixRIFFTag_(tag) {\r\n  if (tag.constructor !== String) {\r\n    throw new Error('Invalid tag name.');\r\n  } else if (tag.length < 4) {\r\n    for (let i = 0, len = 4 - tag.length; i < len; i++) {\r\n      tag += ' ';\r\n    }\r\n  }\r\n  return tag;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}