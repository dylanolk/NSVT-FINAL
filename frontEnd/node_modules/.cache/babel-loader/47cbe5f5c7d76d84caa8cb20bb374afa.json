{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileReader } from './wavefile-reader';\nimport { writeString } from './parsers/write-string';\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\n\nexport class WaveFileParser extends WaveFileReader {\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\n  toBuffer() {\n    this.uInt16.be = this.container === 'RIFX';\n    this.uInt32.be = this.uInt16.be;\n    /** @type {!Array<!Array<number>>} */\n\n    let fileBody = [this.getJunkBytes_(), this.getDs64Bytes_(), this.getBextBytes_(), this.getiXMLBytes_(), this.getFmtBytes_(), this.getFactBytes_(), packString(this.data.chunkId), pack(this.data.samples.length, this.uInt32), this.data.samples, this.getCueBytes_(), this.getSmplBytes_(), this.getLISTBytes_(), this.get_PMXBytes_()];\n    /** @type {number} */\n\n    let fileBodyLength = 0;\n\n    for (let i = 0; i < fileBody.length; i++) {\n      fileBodyLength += fileBody[i].length;\n    }\n    /** @type {!Uint8Array} */\n\n\n    let file = new Uint8Array(fileBodyLength + 12);\n    /** @type {number} */\n\n    let index = 0;\n    index = packStringTo(this.container, file, index);\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\n    index = packStringTo(this.format, file, index);\n\n    for (let i = 0; i < fileBody.length; i++) {\n      file.set(fileBody[i], index);\n      index += fileBody[i].length;\n    }\n\n    return file;\n  }\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\n\n\n  getBextBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    this.enforceBext_();\n\n    if (this.bext.chunkId) {\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\n      bytes = bytes.concat(packString(this.bext.chunkId), pack(602 + this.bext.codingHistory.length, this.uInt32), writeString(this.bext.description, 256), writeString(this.bext.originator, 32), writeString(this.bext.originatorReference, 32), writeString(this.bext.originationDate, 10), writeString(this.bext.originationTime, 8), pack(this.bext.timeReference[0], this.uInt32), pack(this.bext.timeReference[1], this.uInt32), pack(this.bext.version, this.uInt16), writeString(this.bext.UMID, 64), pack(this.bext.loudnessValue, this.uInt16), pack(this.bext.loudnessRange, this.uInt16), pack(this.bext.maxTruePeakLevel, this.uInt16), pack(this.bext.maxMomentaryLoudness, this.uInt16), pack(this.bext.maxShortTermLoudness, this.uInt16), writeString(this.bext.reserved, 180), writeString(this.bext.codingHistory, this.bext.codingHistory.length));\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\n\n\n  enforceBext_() {\n    for (let prop in this.bext) {\n      if (this.bext.hasOwnProperty(prop)) {\n        if (this.bext[prop] && prop != 'timeReference') {\n          this.bext.chunkId = 'bext';\n          break;\n        }\n      }\n    }\n\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\n      this.bext.chunkId = 'bext';\n    }\n  }\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getiXMLBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.iXML.chunkId) {\n      /** @type {!Array<number>} */\n      let iXMLPackedValue = packString(this.iXML.value);\n      this.iXML.chunkSize = iXMLPackedValue.length;\n      bytes = bytes.concat(packString(this.iXML.chunkId), pack(this.iXML.chunkSize, this.uInt32), iXMLPackedValue);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getDs64Bytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.ds64.chunkId) {\n      bytes = bytes.concat(packString(this.ds64.chunkId), pack(this.ds64.chunkSize, this.uInt32), pack(this.ds64.riffSizeHigh, this.uInt32), pack(this.ds64.riffSizeLow, this.uInt32), pack(this.ds64.dataSizeHigh, this.uInt32), pack(this.ds64.dataSizeLow, this.uInt32), pack(this.ds64.originationTime, this.uInt32), pack(this.ds64.sampleCountHigh, this.uInt32), pack(this.ds64.sampleCountLow, this.uInt32));\n    } //if (this.ds64.tableLength) {\n    //  ds64Bytes = ds64Bytes.concat(\n    //    pack(this.ds64.tableLength, this.uInt32),\n    //    this.ds64.table);\n    //}\n\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getCueBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.cue.chunkId) {\n      /** @type {!Array<number>} */\n      let cuePointsBytes = this.getCuePointsBytes_();\n      bytes = bytes.concat(packString(this.cue.chunkId), pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\n      pack(this.cue.dwCuePoints, this.uInt32), cuePointsBytes);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\n\n\n  getCuePointsBytes_() {\n    /** @type {!Array<number>} */\n    let points = [];\n\n    for (let i = 0; i < this.cue.dwCuePoints; i++) {\n      points = points.concat(pack(this.cue.points[i].dwName, this.uInt32), pack(this.cue.points[i].dwPosition, this.uInt32), packString(this.cue.points[i].fccChunk), pack(this.cue.points[i].dwChunkStart, this.uInt32), pack(this.cue.points[i].dwBlockStart, this.uInt32), pack(this.cue.points[i].dwSampleOffset, this.uInt32));\n    }\n\n    return points;\n  }\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getSmplBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.smpl.chunkId) {\n      /** @type {!Array<number>} */\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\n      bytes = bytes.concat(packString(this.smpl.chunkId), pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\n      pack(this.smpl.dwManufacturer, this.uInt32), pack(this.smpl.dwProduct, this.uInt32), pack(this.smpl.dwSamplePeriod, this.uInt32), pack(this.smpl.dwMIDIUnityNote, this.uInt32), pack(this.smpl.dwMIDIPitchFraction, this.uInt32), pack(this.smpl.dwSMPTEFormat, this.uInt32), pack(this.smpl.dwSMPTEOffset, this.uInt32), pack(this.smpl.dwNumSampleLoops, this.uInt32), pack(this.smpl.dwSamplerData, this.uInt32), smplLoopsBytes);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\n\n\n  getSmplLoopsBytes_() {\n    /** @type {!Array<number>} */\n    let loops = [];\n\n    for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n      loops = loops.concat(pack(this.smpl.loops[i].dwName, this.uInt32), pack(this.smpl.loops[i].dwType, this.uInt32), pack(this.smpl.loops[i].dwStart, this.uInt32), pack(this.smpl.loops[i].dwEnd, this.uInt32), pack(this.smpl.loops[i].dwFraction, this.uInt32), pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\n    }\n\n    return loops;\n  }\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getFactBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.fact.chunkId) {\n      bytes = bytes.concat(packString(this.fact.chunkId), pack(this.fact.chunkSize, this.uInt32), pack(this.fact.dwSampleLength, this.uInt32));\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\n\n\n  getFmtBytes_() {\n    /** @type {!Array<number>} */\n    let fmtBytes = [];\n\n    if (this.fmt.chunkId) {\n      /** @type {!Array<number>} */\n      let bytes = fmtBytes.concat(packString(this.fmt.chunkId), pack(this.fmt.chunkSize, this.uInt32), pack(this.fmt.audioFormat, this.uInt16), pack(this.fmt.numChannels, this.uInt16), pack(this.fmt.sampleRate, this.uInt32), pack(this.fmt.byteRate, this.uInt32), pack(this.fmt.blockAlign, this.uInt16), pack(this.fmt.bitsPerSample, this.uInt16), this.getFmtExtensionBytes_());\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n\n    throw Error('Could not find the \"fmt \" chunk');\n  }\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\n\n\n  getFmtExtensionBytes_() {\n    /** @type {!Array<number>} */\n    let extension = [];\n\n    if (this.fmt.chunkSize > 16) {\n      extension = extension.concat(pack(this.fmt.cbSize, this.uInt16));\n    }\n\n    if (this.fmt.chunkSize > 18) {\n      extension = extension.concat(pack(this.fmt.validBitsPerSample, this.uInt16));\n    }\n\n    if (this.fmt.chunkSize > 20) {\n      extension = extension.concat(pack(this.fmt.dwChannelMask, this.uInt32));\n    }\n\n    if (this.fmt.chunkSize > 24) {\n      extension = extension.concat(pack(this.fmt.subformat[0], this.uInt32), pack(this.fmt.subformat[1], this.uInt32), pack(this.fmt.subformat[2], this.uInt32), pack(this.fmt.subformat[3], this.uInt32));\n    }\n\n    return extension;\n  }\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\n\n\n  getLISTBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    for (let i = 0; i < this.LIST.length; i++) {\n      /** @type {!Array<number>} */\n      let subChunksBytes = this.getLISTSubChunksBytes_(this.LIST[i].subChunks, this.LIST[i].format);\n      bytes = bytes.concat(packString(this.LIST[i].chunkId), pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\n      packString(this.LIST[i].format), subChunksBytes);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\n\n\n  getLISTSubChunksBytes_(subChunks, format) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    for (let i = 0, len = subChunks.length; i < len; i++) {\n      if (format == 'INFO') {\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\n      } else if (format == 'adtl') {\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\n      }\n\n      this.enforceByteLen_(bytes);\n    }\n\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n\n\n  getLISTINFOSubChunksBytes_(subChunk) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    /** @type {!Array<number>} */\n\n    let LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n    bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\n    LISTsubChunkValue);\n    bytes.push(0);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n\n\n  getLISTadtlSubChunksBytes_(subChunk) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\n      /** @type {!Array<number>} */\n      let LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n      bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\n      pack(subChunk.dwName, this.uInt32), LISTsubChunkValue);\n      bytes.push(0);\n    } else if (subChunk.chunkId == 'ltxt') {\n      bytes = bytes.concat(this.getLtxtChunkBytes_(subChunk));\n    }\n\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n\n\n  getLtxtChunkBytes_(ltxt) {\n    return [].concat(packString(ltxt.chunkId), pack(ltxt.value.length + 20, this.uInt32), pack(ltxt.dwName, this.uInt32), pack(ltxt.dwSampleLength, this.uInt32), pack(ltxt.dwPurposeID, this.uInt32), pack(ltxt.dwCountry, this.uInt16), pack(ltxt.dwLanguage, this.uInt16), pack(ltxt.dwDialect, this.uInt16), pack(ltxt.dwCodePage, this.uInt16), // should always be a empty string;\n    // kept for compatibility\n    writeString(ltxt.value, ltxt.value.length));\n  }\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\n\n\n  get_PMXBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this._PMX.chunkId) {\n      /** @type {!Array<number>} */\n      let _PMXPackedValue = packString(this._PMX.value);\n\n      this._PMX.chunkSize = _PMXPackedValue.length;\n      bytes = bytes.concat(packString(this._PMX.chunkId), pack(this._PMX.chunkSize, this.uInt32), _PMXPackedValue);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\n\n\n  getJunkBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n\n    if (this.junk.chunkId) {\n      return bytes.concat(packString(this.junk.chunkId), pack(this.junk.chunkData.length, this.uInt32), //chunkSize\n      this.junk.chunkData);\n    }\n\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\n\n\n  enforceByteLen_(bytes) {\n    if (bytes.length % 2) {\n      bytes.push(0);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/wavefile-parser.js"],"names":["WaveFileReader","writeString","packTo","packStringTo","packString","pack","WaveFileParser","toBuffer","uInt16","be","container","uInt32","fileBody","getJunkBytes_","getDs64Bytes_","getBextBytes_","getiXMLBytes_","getFmtBytes_","getFactBytes_","data","chunkId","samples","length","getCueBytes_","getSmplBytes_","getLISTBytes_","get_PMXBytes_","fileBodyLength","i","file","Uint8Array","index","format","set","bytes","enforceBext_","bext","chunkSize","codingHistory","concat","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","enforceByteLen_","prop","hasOwnProperty","iXML","iXMLPackedValue","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","cue","cuePointsBytes","getCuePointsBytes_","dwCuePoints","points","dwName","dwPosition","fccChunk","dwChunkStart","dwBlockStart","dwSampleOffset","smpl","smplLoopsBytes","getSmplLoopsBytes_","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","fact","dwSampleLength","fmtBytes","fmt","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","getFmtExtensionBytes_","Error","extension","cbSize","validBitsPerSample","dwChannelMask","subformat","LIST","subChunksBytes","getLISTSubChunksBytes_","subChunks","len","getLISTINFOSubChunksBytes_","getLISTadtlSubChunksBytes_","subChunk","LISTsubChunkValue","push","indexOf","getLtxtChunkBytes_","ltxt","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","_PMX","_PMXPackedValue","junk","chunkData"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileReader } from './wavefile-reader';\r\nimport { writeString } from './parsers/write-string';\r\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\r\nexport class WaveFileParser extends WaveFileReader {\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\r\n  toBuffer() {\r\n    this.uInt16.be = this.container === 'RIFX';\r\n    this.uInt32.be = this.uInt16.be;\r\n    /** @type {!Array<!Array<number>>} */\r\n    let fileBody = [\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getiXMLBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      packString(this.data.chunkId),\r\n      pack(this.data.samples.length, this.uInt32),\r\n      this.data.samples,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_(),\r\n      this.get_PMXBytes_()\r\n    ];\r\n    /** @type {number} */\r\n    let fileBodyLength = 0;\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      fileBodyLength += fileBody[i].length;\r\n    }\r\n    /** @type {!Uint8Array} */\r\n    let file = new Uint8Array(fileBodyLength + 12);\r\n    /** @type {number} */\r\n    let index = 0;\r\n    index = packStringTo(this.container, file, index);\r\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\r\n    index = packStringTo(this.format, file, index);\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      file.set(fileBody[i], index);\r\n      index += fileBody[i].length;\r\n    }\r\n    return file;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\r\n      bytes = bytes.concat(\r\n        packString(this.bext.chunkId),\r\n        pack(602 + this.bext.codingHistory.length, this.uInt32),\r\n        writeString(this.bext.description, 256),\r\n        writeString(this.bext.originator, 32),\r\n        writeString(this.bext.originatorReference, 32),\r\n        writeString(this.bext.originationDate, 10),\r\n        writeString(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], this.uInt32),\r\n        pack(this.bext.timeReference[1], this.uInt32),\r\n        pack(this.bext.version, this.uInt16),\r\n        writeString(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, this.uInt16),\r\n        pack(this.bext.loudnessRange, this.uInt16),\r\n        pack(this.bext.maxTruePeakLevel, this.uInt16),\r\n        pack(this.bext.maxMomentaryLoudness, this.uInt16),\r\n        pack(this.bext.maxShortTermLoudness, this.uInt16),\r\n        writeString(this.bext.reserved, 180),\r\n        writeString(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (let prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\r\n  getiXMLBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.iXML.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let iXMLPackedValue = packString(this.iXML.value);\r\n      this.iXML.chunkSize = iXMLPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this.iXML.chunkId),\r\n        pack(this.iXML.chunkSize, this.uInt32),\r\n        iXMLPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.ds64.chunkId),\r\n        pack(this.ds64.chunkSize, this.uInt32),\r\n        pack(this.ds64.riffSizeHigh, this.uInt32),\r\n        pack(this.ds64.riffSizeLow, this.uInt32),\r\n        pack(this.ds64.dataSizeHigh, this.uInt32),\r\n        pack(this.ds64.dataSizeLow, this.uInt32),\r\n        pack(this.ds64.originationTime, this.uInt32),\r\n        pack(this.ds64.sampleCountHigh, this.uInt32),\r\n        pack(this.ds64.sampleCountLow, this.uInt32));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, this.uInt32),\r\n    //    this.ds64.table);\r\n    //}\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.cue.chunkId),\r\n        pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\r\n        pack(this.cue.dwCuePoints, this.uInt32),\r\n        cuePointsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i].dwName, this.uInt32),\r\n        pack(this.cue.points[i].dwPosition, this.uInt32),\r\n        packString(this.cue.points[i].fccChunk),\r\n        pack(this.cue.points[i].dwChunkStart, this.uInt32),\r\n        pack(this.cue.points[i].dwBlockStart, this.uInt32),\r\n        pack(this.cue.points[i].dwSampleOffset, this.uInt32));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.smpl.chunkId),\r\n        pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\r\n        pack(this.smpl.dwManufacturer, this.uInt32),\r\n        pack(this.smpl.dwProduct, this.uInt32),\r\n        pack(this.smpl.dwSamplePeriod, this.uInt32),\r\n        pack(this.smpl.dwMIDIUnityNote, this.uInt32),\r\n        pack(this.smpl.dwMIDIPitchFraction, this.uInt32),\r\n        pack(this.smpl.dwSMPTEFormat, this.uInt32),\r\n        pack(this.smpl.dwSMPTEOffset, this.uInt32),\r\n        pack(this.smpl.dwNumSampleLoops, this.uInt32),\r\n        pack(this.smpl.dwSamplerData, this.uInt32),\r\n        smplLoopsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i].dwName, this.uInt32),\r\n        pack(this.smpl.loops[i].dwType, this.uInt32),\r\n        pack(this.smpl.loops[i].dwStart, this.uInt32),\r\n        pack(this.smpl.loops[i].dwEnd, this.uInt32),\r\n        pack(this.smpl.loops[i].dwFraction, this.uInt32),\r\n        pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.fact.chunkId),\r\n        pack(this.fact.chunkSize, this.uInt32),\r\n        pack(this.fact.dwSampleLength, this.uInt32));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let fmtBytes = [];\r\n    if (this.fmt.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let bytes  = fmtBytes.concat(\r\n        packString(this.fmt.chunkId),\r\n        pack(this.fmt.chunkSize, this.uInt32),\r\n        pack(this.fmt.audioFormat, this.uInt16),\r\n        pack(this.fmt.numChannels, this.uInt16),\r\n        pack(this.fmt.sampleRate, this.uInt32),\r\n        pack(this.fmt.byteRate, this.uInt32),\r\n        pack(this.fmt.blockAlign, this.uInt16),\r\n        pack(this.fmt.bitsPerSample, this.uInt16),\r\n        this.getFmtExtensionBytes_());\r\n      this.enforceByteLen_(bytes);\r\n      return bytes;\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, this.uInt32));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], this.uInt32),\r\n        pack(this.fmt.subformat[1], this.uInt32),\r\n        pack(this.fmt.subformat[2], this.uInt32),\r\n        pack(this.fmt.subformat[3], this.uInt32));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i].subChunks, this.LIST[i].format);\r\n      bytes = bytes.concat(\r\n        packString(this.LIST[i].chunkId),\r\n        pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\r\n        packString(this.LIST[i].format),\r\n        subChunksBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i = 0, len = subChunks.length; i < len; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\r\n      } else if (format == 'adtl') {\r\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\r\n      }\r\n      this.enforceByteLen_(bytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTINFOSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    /** @type {!Array<number>} */\r\n    let LISTsubChunkValue = writeString(\r\n        subChunk.value, subChunk.value.length);\r\n    bytes = bytes.concat(\r\n      packString(subChunk.chunkId),\r\n      pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\r\n      LISTsubChunkValue);\r\n    bytes.push(0);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTadtlSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\r\n      /** @type {!Array<number>} */\r\n      let LISTsubChunkValue = writeString(\r\n          subChunk.value,\r\n          subChunk.value.length);\r\n      bytes = bytes.concat(\r\n        packString(subChunk.chunkId),\r\n        pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\r\n        pack(subChunk.dwName, this.uInt32),\r\n        LISTsubChunkValue);\r\n      bytes.push(0);\r\n    } else if (subChunk.chunkId == 'ltxt') {\r\n      bytes = bytes.concat(\r\n        this.getLtxtChunkBytes_(subChunk));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      packString(ltxt.chunkId),\r\n      pack(ltxt.value.length + 20, this.uInt32),\r\n      pack(ltxt.dwName, this.uInt32),\r\n      pack(ltxt.dwSampleLength, this.uInt32),\r\n      pack(ltxt.dwPurposeID, this.uInt32),\r\n      pack(ltxt.dwCountry, this.uInt16),\r\n      pack(ltxt.dwLanguage, this.uInt16),\r\n      pack(ltxt.dwDialect, this.uInt16),\r\n      pack(ltxt.dwCodePage, this.uInt16),\r\n       // should always be a empty string;\r\n       // kept for compatibility\r\n      writeString(ltxt.value, ltxt.value.length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\r\n  get_PMXBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this._PMX.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let _PMXPackedValue = packString(this._PMX.value);\r\n      this._PMX.chunkSize = _PMXPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this._PMX.chunkId),\r\n        pack(this._PMX.chunkSize, this.uInt32),\r\n        _PMXPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        packString(this.junk.chunkId),\r\n        pack(this.junk.chunkData.length, this.uInt32), //chunkSize\r\n        this.junk.chunkData);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\r\n  enforceByteLen_(bytes) {\r\n    if (bytes.length % 2) {\r\n      bytes.push(0);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}