{"ast":null,"code":"/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode UTF8 strings to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\n\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=0] The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\nexport function unpack(buffer) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buffer.length;\n\n  /** @type {string} */\n  let str = '';\n\n  for (let index = start; index < end;) {\n    /** @type {number} */\n    let lowerBoundary = 0x80;\n    /** @type {number} */\n\n    let upperBoundary = 0xBF;\n    /** @type {boolean} */\n\n    let replace = false;\n    /** @type {number} */\n\n    let charCode = buffer[index++];\n\n    if (charCode >= 0x00 && charCode <= 0x7F) {\n      str += String.fromCharCode(charCode);\n    } else {\n      /** @type {number} */\n      let count = 0;\n\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\n        count = 1;\n      } else if (charCode >= 0xE0 && charCode <= 0xEF) {\n        count = 2;\n\n        if (buffer[index] === 0xE0) {\n          lowerBoundary = 0xA0;\n        }\n\n        if (buffer[index] === 0xED) {\n          upperBoundary = 0x9F;\n        }\n      } else if (charCode >= 0xF0 && charCode <= 0xF4) {\n        count = 3;\n\n        if (buffer[index] === 0xF0) {\n          lowerBoundary = 0x90;\n        }\n\n        if (buffer[index] === 0xF4) {\n          upperBoundary = 0x8F;\n        }\n      } else {\n        replace = true;\n      }\n\n      charCode = charCode & (1 << 8 - count - 1) - 1;\n\n      for (let i = 0; i < count; i++) {\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\n          replace = true;\n        }\n\n        charCode = charCode << 6 | buffer[index] & 0x3f;\n        index++;\n      }\n\n      if (replace) {\n        str += String.fromCharCode(0xFFFD);\n      } else if (charCode <= 0xffff) {\n        str += String.fromCharCode(charCode);\n      } else {\n        charCode -= 0x10000;\n        str += String.fromCharCode((charCode >> 10 & 0x3ff) + 0xd800, (charCode & 0x3ff) + 0xdc00);\n      }\n    }\n  }\n\n  return str;\n}\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\n\nexport function pack(str, buffer) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  /** @type {number} */\n  let i = 0;\n  /** @type {number} */\n\n  let len = str.length;\n\n  while (i < len) {\n    /** @type {number} */\n    let codePoint = str.codePointAt(i);\n\n    if (codePoint < 128) {\n      buffer[index] = codePoint;\n      index++;\n    } else {\n      /** @type {number} */\n      let count = 0;\n      /** @type {number} */\n\n      let offset = 0;\n\n      if (codePoint <= 0x07FF) {\n        count = 1;\n        offset = 0xC0;\n      } else if (codePoint <= 0xFFFF) {\n        count = 2;\n        offset = 0xE0;\n      } else if (codePoint <= 0x10FFFF) {\n        count = 3;\n        offset = 0xF0;\n        i++;\n      }\n\n      buffer[index] = (codePoint >> 6 * count) + offset;\n      index++;\n\n      while (count > 0) {\n        buffer[index] = 0x80 | codePoint >> 6 * (count - 1) & 0x3F;\n        index++;\n        count--;\n      }\n    }\n\n    i++;\n  }\n\n  return index;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/parsers/binary/lib/utf8-parser.js"],"names":["unpack","buffer","start","end","length","str","index","lowerBoundary","upperBoundary","replace","charCode","String","fromCharCode","count","i","pack","len","codePoint","codePointAt","offset"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode UTF8 strings to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=0] The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\r\nexport function unpack(buffer, start=0, end=buffer.length) {\r\n  /** @type {string} */\r\n  let str = '';\r\n  for(let index = start; index < end;) {\r\n    /** @type {number} */\r\n    let lowerBoundary = 0x80;\r\n    /** @type {number} */\r\n    let upperBoundary = 0xBF;\r\n    /** @type {boolean} */\r\n    let replace = false;\r\n    /** @type {number} */\r\n    let charCode = buffer[index++];\r\n    if (charCode >= 0x00 && charCode <= 0x7F) {\r\n      str += String.fromCharCode(charCode);\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\r\n        count = 1;\r\n      } else if (charCode >= 0xE0 && charCode <= 0xEF ) {\r\n        count = 2;\r\n        if (buffer[index] === 0xE0) {\r\n          lowerBoundary = 0xA0;\r\n        }\r\n        if (buffer[index] === 0xED) {\r\n          upperBoundary = 0x9F;\r\n        }\r\n      } else if (charCode >= 0xF0 && charCode <= 0xF4 ) {\r\n        count = 3;\r\n        if (buffer[index] === 0xF0) {\r\n          lowerBoundary = 0x90;\r\n        }\r\n        if (buffer[index] === 0xF4) {\r\n          upperBoundary = 0x8F;\r\n        }\r\n      } else {\r\n        replace = true;\r\n      }\r\n      charCode = charCode & (1 << (8 - count - 1)) - 1;\r\n      for (let i = 0; i < count; i++) {\r\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\r\n          replace = true;\r\n        }\r\n        charCode = (charCode << 6) | (buffer[index] & 0x3f);\r\n        index++;\r\n      }\r\n      if (replace) {\r\n        str += String.fromCharCode(0xFFFD);\r\n      } \r\n      else if (charCode <= 0xffff) {\r\n        str += String.fromCharCode(charCode);\r\n      } else {\r\n        charCode -= 0x10000;\r\n        str += String.fromCharCode(\r\n          ((charCode >> 10) & 0x3ff) + 0xd800,\r\n          (charCode & 0x3ff) + 0xdc00);\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function pack(str, buffer, index=0) {\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let len = str.length;\r\n  while (i < len) {\r\n    /** @type {number} */\r\n    let codePoint = str.codePointAt(i);\r\n    if (codePoint < 128) {\r\n      buffer[index] = codePoint;\r\n      index++;\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      /** @type {number} */\r\n      let offset = 0;\r\n      if (codePoint <= 0x07FF) {\r\n        count = 1;\r\n        offset = 0xC0;\r\n      } else if(codePoint <= 0xFFFF) {\r\n        count = 2;\r\n        offset = 0xE0;\r\n      } else if(codePoint <= 0x10FFFF) {\r\n        count = 3;\r\n        offset = 0xF0;\r\n        i++;\r\n      }\r\n      buffer[index] = (codePoint >> (6 * count)) + offset;\r\n      index++;\r\n      while (count > 0) {\r\n        buffer[index] = 0x80 | (codePoint >> (6 * (count - 1)) & 0x3F);\r\n        index++;\r\n        count--;\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return index;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}