{"ast":null,"code":"/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\n\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\nexport class FloatParser {\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\n  constructor(ebits, fbits) {\n    /**\r\n     * @type {number}\r\n     */\n    this.offset = Math.ceil((ebits + fbits) / 8);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.ebits = ebits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.fbits = fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.bias = (1 << ebits - 1) - 1;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.biasP2 = Math.pow(2, this.bias + 1);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.ebitsFbits = ebits + fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\n  }\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\n\n\n  pack(buffer, num, index) {\n    // Round overflows\n    if (Math.abs(num) > this.biasP2 - this.ebitsFbits * 2) {\n      num = num < 0 ? -Infinity : Infinity;\n    }\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\n\n\n    let sign = ((num = +num) || 1 / num) < 0 ? 1 : num < 0 ? 1 : 0;\n    num = Math.abs(num);\n    /** @type {number} */\n\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\n    /** @type {number} */\n\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits)); // NaN\n\n    if (num !== num) {\n      fraction = Math.pow(2, this.fbits - 1);\n      exp = (1 << this.ebits) - 1; // Number\n    } else if (num !== 0) {\n      if (num >= Math.pow(2, 1 - this.bias)) {\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\n          exp = exp + 1;\n          fraction = 1;\n        } // Overflow\n\n\n        if (exp > this.bias) {\n          exp = (1 << this.ebits) - 1;\n          fraction = 0;\n        } else {\n          exp = exp + this.bias;\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\n        }\n      } else {\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\n        exp = 0;\n      }\n    }\n\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\n  }\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\n\n\n  unpack(buffer, index) {\n    /** @type {number} */\n    let eMax = (1 << this.ebits) - 1;\n    /** @type {number} */\n\n    let significand;\n    /** @type {string} */\n\n    let leftBits = \"\";\n\n    for (let i = this.offset - 1; i >= 0; i--) {\n      /** @type {string} */\n      let t = buffer[i + index].toString(2);\n      leftBits += \"00000000\".substring(t.length) + t;\n    }\n    /** @type {number} */\n\n\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\n    leftBits = leftBits.substring(1);\n    /** @type {number} */\n\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\n    leftBits = leftBits.substring(this.ebits);\n\n    if (exponent == eMax) {\n      if (parseInt(leftBits, 2) !== 0) {\n        return NaN;\n      }\n\n      return sign * Infinity;\n    } else if (exponent === 0) {\n      exponent += 1;\n      significand = parseInt(leftBits, 2);\n    } else {\n      significand = parseInt(\"1\" + leftBits, 2);\n    }\n\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\n  }\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  packFloatBits_(buffer, index, sign, exp, fraction) {\n    /** @type {!Array<number>} */\n    let bits = []; // the sign\n\n    bits.push(sign); // the exponent\n\n    for (let i = this.ebits; i > 0; i -= 1) {\n      bits[i] = exp % 2 ? 1 : 0;\n      exp = Math.floor(exp / 2);\n    } // the fraction\n\n\n    let len = bits.length;\n\n    for (let i = this.fbits; i > 0; i -= 1) {\n      bits[len + i] = fraction % 2 ? 1 : 0;\n      fraction = Math.floor(fraction / 2);\n    } // pack as bytes\n\n    /** @type {string} */\n\n\n    let str = bits.join('');\n    /** @type {number} */\n\n    let offset = this.offset + index - 1;\n    /** @type {number} */\n\n    let k = index;\n\n    while (offset >= index) {\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\n      str = str.substring(8);\n      offset--;\n      k++;\n    }\n\n    return k;\n  }\n\n}\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\n\nfunction roundToEven(n) {\n  /** @type {number} */\n  let w = Math.floor(n);\n  let f = n - w;\n\n  if (f < 0.5) {\n    return w;\n  }\n\n  if (f > 0.5) {\n    return w + 1;\n  }\n\n  return w % 2 ? w + 1 : w;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/parsers/binary/lib/float-parser.js"],"names":["FloatParser","constructor","ebits","fbits","offset","Math","ceil","bias","biasP2","pow","ebitsFbits","fbias","pack","buffer","num","index","abs","Infinity","sign","exp","min","floor","log","LN2","fraction","roundToEven","packFloatBits_","unpack","eMax","significand","leftBits","i","t","toString","substring","length","charAt","exponent","parseInt","NaN","bits","push","len","str","join","k","n","w","f"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\r\n\r\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\r\nexport class FloatParser {\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\r\n  constructor(ebits, fbits) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil((ebits + fbits) / 8);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebits = ebits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbits = fbits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bias = (1 << (ebits - 1)) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.biasP2 = Math.pow(2, this.bias + 1);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebitsFbits = (ebits + fbits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\r\n  pack(buffer, num, index) {\r\n    // Round overflows\r\n    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {\r\n      num = num < 0 ? -Infinity : Infinity;\r\n    }\r\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\r\n    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;\r\n    num = Math.abs(num);\r\n    /** @type {number} */\r\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\r\n    /** @type {number} */\r\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\r\n    // NaN\r\n    if (num !== num) {\r\n      fraction = Math.pow(2, this.fbits - 1);\r\n      exp = (1 << this.ebits) - 1;\r\n    // Number\r\n    } else if (num !== 0) {\r\n      if (num >= Math.pow(2, 1 - this.bias)) {\r\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\r\n          exp = exp + 1;\r\n          fraction = 1;\r\n        }\r\n        // Overflow\r\n        if (exp > this.bias) {\r\n          exp = (1 << this.ebits) - 1;\r\n          fraction = 0;\r\n        } else {\r\n          exp = exp + this.bias;\r\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\r\n        }\r\n      } else {\r\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\r\n        exp = 0;\r\n      } \r\n    }\r\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\r\n  }\r\n\r\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\r\n  unpack(buffer, index) {\r\n    /** @type {number} */\r\n    let eMax = (1 << this.ebits) - 1;\r\n    /** @type {number} */\r\n    let significand;\r\n    /** @type {string} */\r\n    let leftBits = \"\";\r\n    for (let i = this.offset - 1; i >= 0 ; i--) {\r\n      /** @type {string} */\r\n      let t = buffer[i + index].toString(2);\r\n      leftBits += \"00000000\".substring(t.length) + t;\r\n    }\r\n    /** @type {number} */\r\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\r\n    leftBits = leftBits.substring(1);\r\n    /** @type {number} */\r\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\r\n    leftBits = leftBits.substring(this.ebits);\r\n    if (exponent == eMax) {\r\n      if (parseInt(leftBits, 2) !== 0) {\r\n        return NaN;\r\n      }\r\n      return sign * Infinity;  \r\n    } else if (exponent === 0) {\r\n      exponent += 1;\r\n      significand = parseInt(leftBits, 2);\r\n    } else {\r\n      significand = parseInt(\"1\" + leftBits, 2);\r\n    }\r\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  packFloatBits_(buffer, index, sign, exp, fraction) {\r\n    /** @type {!Array<number>} */\r\n    let bits = [];\r\n    // the sign\r\n    bits.push(sign);\r\n    // the exponent\r\n    for (let i = this.ebits; i > 0; i -= 1) {\r\n      bits[i] = (exp % 2 ? 1 : 0);\r\n      exp = Math.floor(exp / 2);\r\n    }\r\n    // the fraction\r\n    let len = bits.length;\r\n    for (let i = this.fbits; i > 0; i -= 1) {\r\n      bits[len + i] = (fraction % 2 ? 1 : 0);\r\n      fraction = Math.floor(fraction / 2);\r\n    }\r\n    // pack as bytes\r\n    /** @type {string} */\r\n    let str = bits.join('');\r\n    /** @type {number} */\r\n    let offset = this.offset + index - 1;\r\n    /** @type {number} */\r\n    let k = index;\r\n    while (offset >= index) {\r\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\r\n      str = str.substring(8);\r\n      offset--;\r\n      k++;\r\n    }\r\n    return k;\r\n  }\r\n}\r\n\r\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction roundToEven(n) {\r\n  /** @type {number} */\r\n  let w = Math.floor(n);\r\n  let f = n - w;\r\n  if (f < 0.5) {\r\n    return w;\r\n  }\r\n  if (f > 0.5) {\r\n    return w + 1;\r\n  }\r\n  return w % 2 ? w + 1 : w;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}