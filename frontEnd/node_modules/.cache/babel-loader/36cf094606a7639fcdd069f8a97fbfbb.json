{"ast":null,"code":"/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2016 acida. MIT License.  \r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview IMA ADPCM codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/imaadpcm\r\n */\n\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\nconst INDEX_TABLE = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\n\nconst STEP_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Int16Array} samples A array of samples.\r\n * @return {!Uint8Array}\r\n */\n\nexport function encode(samples) {\n  /** @type {!Object} */\n  let state = {\n    index: 0,\n    predicted: 0,\n    step: 7\n  };\n  /** @type {!Uint8Array} */\n\n  let adpcmSamples = new Uint8Array(samples.length);\n  /** @type {!Array<number>} */\n\n  let block = [];\n  /** @type {number} */\n\n  let fileIndex = 0;\n  /** @type {number} */\n\n  let blockCount = 0;\n\n  for (let i = 0, len = samples.length; i < len; i++) {\n    if (i % 505 == 0 && i != 0) {\n      adpcmSamples.set(encodeBlock(block, state), fileIndex);\n      fileIndex += 256;\n      block = [];\n      blockCount++;\n    }\n\n    block.push(samples[i]);\n  }\n\n  let samplesLength = samples.length / 2;\n\n  if (samplesLength % 2) {\n    samplesLength++;\n  }\n\n  return adpcmSamples.slice(0, samplesLength + 512 + blockCount * 4);\n}\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Int16Array}\r\n */\n\nexport function decode(adpcmSamples) {\n  let blockAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n\n  /** @type {!Object} */\n  let state = {\n    index: 0,\n    predicted: 0,\n    step: 7\n  };\n  /** @type {!Int16Array} */\n\n  let samples = new Int16Array(adpcmSamples.length * 2);\n  /** @type {!Array<number>} */\n\n  let block = [];\n  /** @type {number} */\n\n  let fileIndex = 0;\n\n  for (let i = 0, len = adpcmSamples.length; i < len; i++) {\n    if (i % blockAlign == 0 && i != 0) {\n      let decoded = decodeBlock(block, state);\n      samples.set(decoded, fileIndex);\n      fileIndex += decoded.length;\n      block = [];\n    }\n\n    block.push(adpcmSamples[i]);\n  }\n\n  return samples;\n}\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n */\n\nfunction encodeBlock(block, state) {\n  /** @type {!Array<number>} */\n  let adpcmSamples = blockHead_(block[0], state);\n\n  for (let i = 3, len = block.length; i < len; i += 2) {\n    /** @type {number} */\n    let sample2 = encodeSample_(block[i], state);\n    /** @type {number} */\n\n    let sample = encodeSample_(block[i + 1], state);\n    adpcmSamples.push(sample << 4 | sample2);\n  }\n\n  return adpcmSamples;\n}\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @param {!Object} state The decoder state.\r\n * @return {!Array<number>}\r\n */\n\n\nfunction decodeBlock(block, state) {\n  state.predicted = sign_(block[1] << 8 | block[0]);\n  state.index = block[2];\n  state.step = STEP_TABLE[state.index];\n  /** @type {!Array<number>} */\n\n  let result = [state.predicted, state.predicted];\n\n  for (let i = 4, len = block.length; i < len; i++) {\n    /** @type {number} */\n    let original_sample = block[i];\n    /** @type {number} */\n\n    let second_sample = original_sample >> 4;\n    /** @type {number} */\n\n    let first_sample = second_sample << 4 ^ original_sample;\n    result.push(decodeSample_(first_sample, state));\n    result.push(decodeSample_(second_sample, state));\n  }\n\n  return result;\n}\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\n\n\nfunction sign_(num) {\n  return num > 32768 ? num - 65536 : num;\n}\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @param {!Object} state The encoder state.\r\n * @return {number}\r\n * @private\r\n */\n\n\nfunction encodeSample_(sample, state) {\n  /** @type {number} */\n  let delta = sample - state.predicted;\n  /** @type {number} */\n\n  let value = 0;\n\n  if (delta >= 0) {\n    value = 0;\n  } else {\n    value = 8;\n    delta = -delta;\n  }\n  /** @type {number} */\n\n\n  let step = STEP_TABLE[state.index];\n  /** @type {number} */\n\n  let diff = step >> 3;\n\n  if (delta > step) {\n    value |= 4;\n    delta -= step;\n    diff += step;\n  }\n\n  step >>= 1;\n\n  if (delta > step) {\n    value |= 2;\n    delta -= step;\n    diff += step;\n  }\n\n  step >>= 1;\n\n  if (delta > step) {\n    value |= 1;\n    diff += step;\n  }\n\n  updateEncoder_(value, diff, state);\n  return value;\n}\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @param {!Object} state The encoder state.\r\n * @private\r\n */\n\n\nfunction updateEncoder_(value, diff, state) {\n  if (value & 8) {\n    state.predicted -= diff;\n  } else {\n    state.predicted += diff;\n  }\n\n  if (state.predicted < -0x8000) {\n    state.predicted = -0x8000;\n  } else if (state.predicted > 0x7fff) {\n    state.predicted = 0x7fff;\n  }\n\n  state.index += INDEX_TABLE[value & 7];\n\n  if (state.index < 0) {\n    state.index = 0;\n  } else if (state.index > 88) {\n    state.index = 88;\n  }\n}\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @return {number}\r\n * @private\r\n */\n\n\nfunction decodeSample_(nibble, state) {\n  /** @type {number} */\n  let difference = 0;\n\n  if (nibble & 4) {\n    difference += state.step;\n  }\n\n  if (nibble & 2) {\n    difference += state.step >> 1;\n  }\n\n  if (nibble & 1) {\n    difference += state.step >> 2;\n  }\n\n  difference += state.step >> 3;\n\n  if (nibble & 8) {\n    difference = -difference;\n  }\n\n  state.predicted += difference;\n\n  if (state.predicted > 32767) {\n    state.predicted = 32767;\n  } else if (state.predicted < -32767) {\n    state.predicted = -32767;\n  }\n\n  updateDecoder_(nibble, state);\n  return state.predicted;\n}\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @private\r\n */\n\n\nfunction updateDecoder_(nibble, state) {\n  state.index += INDEX_TABLE[nibble];\n\n  if (state.index < 0) {\n    state.index = 0;\n  } else if (state.index > 88) {\n    state.index = 88;\n  }\n\n  state.step = STEP_TABLE[state.index];\n}\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n * @private\r\n */\n\n\nfunction blockHead_(sample, state) {\n  encodeSample_(sample, state);\n  /** @type {!Array<number>} */\n\n  let adpcmSamples = [];\n  adpcmSamples.push(sample & 0xFF);\n  adpcmSamples.push(sample >> 8 & 0xFF);\n  adpcmSamples.push(state.index);\n  adpcmSamples.push(0);\n  return adpcmSamples;\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/codecs/imaadpcm.js"],"names":["INDEX_TABLE","STEP_TABLE","encode","samples","state","index","predicted","step","adpcmSamples","Uint8Array","length","block","fileIndex","blockCount","i","len","set","encodeBlock","push","samplesLength","slice","decode","blockAlign","Int16Array","decoded","decodeBlock","blockHead_","sample2","encodeSample_","sample","sign_","result","original_sample","second_sample","first_sample","decodeSample_","num","delta","value","diff","updateEncoder_","nibble","difference","updateDecoder_"],"mappings":"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","sourcesContent":["/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2016 acida. MIT License.  \r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview IMA ADPCM codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/imaadpcm\r\n */\r\n\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst INDEX_TABLE = [\r\n    -1, -1, -1, -1, 2, 4, 6, 8,\r\n    -1, -1, -1, -1, 2, 4, 6, 8];\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst STEP_TABLE = [\r\n    7, 8, 9, 10, 11, 12, 13, 14,\r\n    16, 17, 19, 21, 23, 25, 28, 31,\r\n    34, 37, 41, 45, 50, 55, 60, 66,\r\n    73, 80, 88, 97, 107, 118, 130, 143,\r\n    157, 173, 190, 209, 230, 253, 279, 307,\r\n    337, 371, 408, 449, 494, 544, 598, 658,\r\n    724, 796, 876, 963, 1060, 1166, 1282, 1411,\r\n    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\r\n    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,\r\n    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\r\n    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n    32767];\r\n\r\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Int16Array} samples A array of samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Uint8Array} */\r\n  let adpcmSamples = new Uint8Array((samples.length));\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  /** @type {number} */\r\n  let blockCount = 0;\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    if ((i % 505 == 0 && i != 0)) {\r\n      adpcmSamples.set(encodeBlock(block, state), fileIndex);\r\n      fileIndex += 256;\r\n      block = [];\r\n      blockCount++;\r\n    }\r\n    block.push(samples[i]);\r\n  }\r\n  let samplesLength = samples.length / 2;\r\n  if (samplesLength % 2) {\r\n    samplesLength++;\r\n  }\r\n  return adpcmSamples.slice(0, samplesLength + 512 + blockCount * 4);\r\n}\r\n\r\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(adpcmSamples, blockAlign=256) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Int16Array} */\r\n  let samples = new Int16Array(adpcmSamples.length * 2);\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  for (let i = 0, len = adpcmSamples.length; i < len; i++) {\r\n    if (i % blockAlign == 0 && i != 0) {            \r\n      let decoded = decodeBlock(block, state);\r\n      samples.set(decoded, fileIndex);\r\n      fileIndex += decoded.length;\r\n      block = [];\r\n    }\r\n    block.push(adpcmSamples[i]);\r\n  }\r\n  return samples;\r\n}\r\n\r\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction encodeBlock(block, state) {\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = blockHead_(block[0], state);\r\n  for (let i = 3, len = block.length; i < len; i+=2) {\r\n    /** @type {number} */\r\n    let sample2 = encodeSample_(block[i], state);\r\n    /** @type {number} */\r\n    let sample = encodeSample_(block[i + 1], state);\r\n    adpcmSamples.push((sample << 4) | sample2);\r\n  }\r\n  return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @param {!Object} state The decoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction decodeBlock(block, state) {\r\n  state.predicted = sign_((block[1] << 8) | block[0]);\r\n  state.index = block[2];\r\n  state.step = STEP_TABLE[state.index];\r\n  /** @type {!Array<number>} */\r\n  let result = [\r\n      state.predicted,\r\n      state.predicted\r\n    ];\r\n  for (let i = 4, len = block.length; i < len; i++) {\r\n    /** @type {number} */\r\n    let original_sample = block[i];\r\n    /** @type {number} */\r\n    let second_sample = original_sample >> 4;\r\n    /** @type {number} */\r\n    let first_sample = (second_sample << 4) ^ original_sample;\r\n    result.push(decodeSample_(first_sample, state));\r\n    result.push(decodeSample_(second_sample, state));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sign_(num) {\r\n  return num > 32768 ? num - 65536 : num;\r\n}\r\n\r\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @param {!Object} state The encoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction encodeSample_(sample, state) {\r\n  /** @type {number} */\r\n  let delta = sample - state.predicted;\r\n  /** @type {number} */\r\n  let value = 0;\r\n  if (delta >= 0) {\r\n    value = 0;\r\n  } else {\r\n    value = 8;\r\n    delta = -delta;\r\n  }\r\n  /** @type {number} */\r\n  let step = STEP_TABLE[state.index];\r\n  /** @type {number} */\r\n  let diff = step >> 3;\r\n  if (delta > step) {\r\n    value |= 4;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 2;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 1;\r\n    diff += step;\r\n  }\r\n  updateEncoder_(value, diff, state);\r\n  return value;\r\n}\r\n\r\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @param {!Object} state The encoder state.\r\n * @private\r\n */\r\nfunction updateEncoder_(value, diff, state) {\r\n  if (value & 8) {\r\n    state.predicted -= diff;\r\n  } else {\r\n    state.predicted += diff;\r\n  }\r\n  if (state.predicted < -0x8000) {\r\n    state.predicted = -0x8000;\r\n  } else if (state.predicted > 0x7fff) {\r\n    state.predicted = 0x7fff;\r\n  }\r\n  state.index += INDEX_TABLE[value & 7];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n}\r\n\r\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction decodeSample_(nibble, state) {\r\n  /** @type {number} */\r\n  let difference = 0;\r\n  if (nibble & 4) {\r\n    difference += state.step;\r\n  }\r\n  if (nibble & 2) {\r\n    difference += state.step >> 1;\r\n  }\r\n  if (nibble & 1) {\r\n    difference += state.step >> 2;\r\n  }\r\n  difference += state.step >> 3;\r\n  if (nibble & 8) {\r\n    difference = -difference;\r\n  }\r\n  state.predicted += difference;\r\n  if (state.predicted > 32767) {\r\n    state.predicted = 32767;\r\n  } else if (state.predicted < -32767) {\r\n    state.predicted = -32767;\r\n  }\r\n  updateDecoder_(nibble, state);\r\n  return state.predicted;\r\n}\r\n\r\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @private\r\n */\r\nfunction updateDecoder_(nibble, state) {\r\n  state.index += INDEX_TABLE[nibble];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n  state.step = STEP_TABLE[state.index];\r\n}\r\n\r\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction blockHead_(sample, state) {\r\n  encodeSample_(sample, state);\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = [];\r\n  adpcmSamples.push(sample & 0xFF);\r\n  adpcmSamples.push((sample >> 8) & 0xFF);\r\n  adpcmSamples.push(state.index);\r\n  adpcmSamples.push(0);\r\n  return adpcmSamples;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}