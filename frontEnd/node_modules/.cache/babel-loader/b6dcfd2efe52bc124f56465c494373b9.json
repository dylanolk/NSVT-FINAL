{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview A module to change the bit depth of PCM samples.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/bitdepth\r\n */\n\n/**\r\n * Change the bit depth of PCM samples.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {string} bithDepth The original bit depth.\r\n * @param {!TypedArray} newSamples The output array.\r\n * @param {string} targetBitDepth The target bit depth.\r\n * @throws {Error} If original or target bit depths are not valid.\r\n */\nexport function changeBitDepth(samples, bithDepth, newSamples, targetBitDepth) {\n  // float to float, just copy the values\n  if ([\"32f\", \"64\"].indexOf(bithDepth) > -1 && [\"32f\", \"64\"].indexOf(targetBitDepth) > -1) {\n    newSamples.set(samples);\n    return;\n  }\n\n  validateBitDepth_(bithDepth);\n  validateBitDepth_(targetBitDepth);\n  /** @type {!Function} */\n\n  let toFunction = getBitDepthFunction_(bithDepth, targetBitDepth);\n  /** @type {!Object<string, number>} */\n\n  let options = {\n    oldMin: Math.pow(2, parseInt(bithDepth, 10)) / 2,\n    newMin: Math.pow(2, parseInt(targetBitDepth, 10)) / 2,\n    oldMax: Math.pow(2, parseInt(bithDepth, 10)) / 2 - 1,\n    newMax: Math.pow(2, parseInt(targetBitDepth, 10)) / 2 - 1\n  }; // sign the samples if original is 8-bit\n\n  sign8Bit_(bithDepth, samples, true); // change the resolution of the samples\n\n  for (let i = 0, len = samples.length; i < len; i++) {\n    newSamples[i] = toFunction(samples[i], options);\n  } // unsign the samples if target is 8-bit\n\n\n  sign8Bit_(targetBitDepth, newSamples, false);\n}\n/**\r\n * Change the bit depth from int to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\n\nfunction intToInt_(sample, args) {\n  if (sample > 0) {\n    sample = parseInt(sample / args.oldMax * args.newMax, 10);\n  } else {\n    sample = parseInt(sample / args.oldMin * args.newMin, 10);\n  }\n\n  return sample;\n}\n/**\r\n * Change the bit depth from float to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\n\n\nfunction floatToInt_(sample, args) {\n  return parseInt(sample > 0 ? sample * args.newMax : sample * args.newMin, 10);\n}\n/**\r\n * Change the bit depth from int to float.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\n\n\nfunction intToFloat_(sample, args) {\n  return sample > 0 ? sample / args.oldMax : sample / args.oldMin;\n}\n/**\r\n * Return the function to change the bit depth of a sample.\r\n * @param {string} original The original bit depth of the data.\r\n * @param {string} target The new bit depth of the data.\r\n * @return {!Function}\r\n * @private\r\n */\n\n\nfunction getBitDepthFunction_(original, target) {\n  /** @type {!Function} */\n  let func = function (x) {\n    return x;\n  };\n\n  if (original != target) {\n    if ([\"32f\", \"64\"].includes(original)) {\n      func = floatToInt_;\n    } else {\n      if ([\"32f\", \"64\"].includes(target)) {\n        func = intToFloat_;\n      } else {\n        func = intToInt_;\n      }\n    }\n  }\n\n  return func;\n}\n/**\r\n * Validate the bit depth.\r\n * @param {string} bitDepth The original bit depth.\r\n * @throws {Error} If bit depth is not valid.\r\n * @private\r\n */\n\n\nfunction validateBitDepth_(bitDepth) {\n  if (bitDepth != \"32f\" && bitDepth != \"64\" && (parseInt(bitDepth, 10) < \"8\" || parseInt(bitDepth, 10) > \"53\")) {\n    throw new Error(\"Invalid bit depth.\");\n  }\n}\n/**\r\n * Sign samples if they are 8-bit.\r\n * @param {string} bitDepth The bit depth code.\r\n * @param {!Array|!TypedArray} samples The samples.\r\n * @param {boolean} sign True to sign, false to unsign.\r\n * @private\r\n */\n\n\nfunction sign8Bit_(bitDepth, samples, sign) {\n  if (bitDepth == \"8\") {\n    let factor = sign ? -128 : 128;\n\n    for (let i = 0, len = samples.length; i < len; i++) {\n      samples[i] = samples[i] += factor;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/kevin/Documents/GitHub/Nyquist_Shannon_MVP/frontEnd/node_modules/wavefile/lib/codecs/bitdepth.js"],"names":["changeBitDepth","samples","bithDepth","newSamples","targetBitDepth","indexOf","set","validateBitDepth_","toFunction","getBitDepthFunction_","options","oldMin","Math","pow","parseInt","newMin","oldMax","newMax","sign8Bit_","i","len","length","intToInt_","sample","args","floatToInt_","intToFloat_","original","target","func","x","includes","bitDepth","Error","sign","factor"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A module to change the bit depth of PCM samples.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/bitdepth\r\n */\r\n\r\n/**\r\n * Change the bit depth of PCM samples.\r\n * @param {!Array|!TypedArray} samples The original samples.\r\n * @param {string} bithDepth The original bit depth.\r\n * @param {!TypedArray} newSamples The output array.\r\n * @param {string} targetBitDepth The target bit depth.\r\n * @throws {Error} If original or target bit depths are not valid.\r\n */\r\nexport function changeBitDepth(samples, bithDepth, newSamples, targetBitDepth) {\r\n  // float to float, just copy the values\r\n  if ([\"32f\",\"64\"].indexOf(bithDepth) > -1 &&\r\n    [\"32f\",\"64\"].indexOf(targetBitDepth) > -1) {\r\n    newSamples.set(samples);\r\n    return;\r\n  }\r\n  validateBitDepth_(bithDepth);\r\n  validateBitDepth_(targetBitDepth);\r\n  /** @type {!Function} */\r\n  let toFunction = getBitDepthFunction_(bithDepth, targetBitDepth);\r\n  /** @type {!Object<string, number>} */\r\n  let options = {\r\n    oldMin: Math.pow(2, parseInt(bithDepth, 10)) / 2,\r\n    newMin: Math.pow(2, parseInt(targetBitDepth, 10)) / 2,\r\n    oldMax: (Math.pow(2, parseInt(bithDepth, 10)) / 2) - 1,\r\n    newMax: (Math.pow(2, parseInt(targetBitDepth, 10)) / 2) - 1,\r\n  };\r\n  // sign the samples if original is 8-bit\r\n  sign8Bit_(bithDepth, samples, true);\r\n  // change the resolution of the samples\r\n  for (let i = 0, len = samples.length; i < len; i++) {        \r\n    newSamples[i] = toFunction(samples[i], options);\r\n  }\r\n  // unsign the samples if target is 8-bit\r\n  sign8Bit_(targetBitDepth, newSamples, false);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToInt_(sample, args) {\r\n  if (sample > 0) {\r\n    sample = parseInt((sample / args.oldMax) * args.newMax, 10);\r\n  } else {\r\n    sample = parseInt((sample / args.oldMin) * args.newMin, 10);\r\n  }\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToInt_(sample, args) {\r\n  return parseInt(\r\n    sample > 0 ? sample * args.newMax : sample * args.newMin, 10);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to float.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToFloat_(sample, args) {\r\n  return sample > 0 ? sample / args.oldMax : sample / args.oldMin;\r\n}\r\n\r\n/**\r\n * Return the function to change the bit depth of a sample.\r\n * @param {string} original The original bit depth of the data.\r\n * @param {string} target The new bit depth of the data.\r\n * @return {!Function}\r\n * @private\r\n */\r\nfunction getBitDepthFunction_(original, target) {\r\n  /** @type {!Function} */\r\n  let func = function(x) {return x;};\r\n  if (original != target) {\r\n    if ([\"32f\", \"64\"].includes(original)) {\r\n      func = floatToInt_;\r\n    } else {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = intToFloat_;\r\n      } else {\r\n        func = intToInt_;\r\n      }\r\n    }\r\n  }\r\n  return func;\r\n}\r\n\r\n/**\r\n * Validate the bit depth.\r\n * @param {string} bitDepth The original bit depth.\r\n * @throws {Error} If bit depth is not valid.\r\n * @private\r\n */\r\nfunction validateBitDepth_(bitDepth) {\r\n  if ((bitDepth != \"32f\" && bitDepth != \"64\") &&\r\n      (parseInt(bitDepth, 10) < \"8\" || parseInt(bitDepth, 10) > \"53\")) {\r\n    throw new Error(\"Invalid bit depth.\");\r\n  }\r\n}\r\n\r\n/**\r\n * Sign samples if they are 8-bit.\r\n * @param {string} bitDepth The bit depth code.\r\n * @param {!Array|!TypedArray} samples The samples.\r\n * @param {boolean} sign True to sign, false to unsign.\r\n * @private\r\n */\r\nfunction sign8Bit_(bitDepth, samples, sign) {\r\n  if (bitDepth == \"8\") {\r\n    let factor = sign ? -128 : 128;\r\n    for (let i = 0, len = samples.length; i < len; i++) {\r\n      samples[i] = samples[i] += factor;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}